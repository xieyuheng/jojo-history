#+html_head: <link rel="stylesheet" href="css/org-page.css"/>
#+property: tangle jojo.py
#+title: jojo's programming adventure in python

* [todo-stack]

*** numpy and pandas as built-in ?

*** Stack as a real class

*** stdlib in core

***** file io in core

***** socket io in core

*** (clone)

*** fix the use of doublequote

*** actor

***** bind aid to address

***** global var in actor

***** link actors

***** actor monitor

*** how to use python decorator in jojo ?

*** error handling

***** parse_sexp_vect -- error handling

      - to be able to use it in jojo

*** improvement

***** inline module_debug_one_step and module_repl_one_step

      - to avoid the use of 'try & except'

* prolog

*** import

    #+begin_src python
    import inspect
    import types
    import importlib
    import sys
    import os
    import itertools
    import collections
    import operator
    import traceback
    import pprint
    import time
    import multiprocessing as mp
    import queue
    import random
    #+end_src

*** utility

***** get_signature

      #+begin_src python
      def get_signature(fun):
          try:
              return inspect.signature(fun)
          except ValueError:
              return None
      #+end_src

***** fun_p

      #+begin_src python
      def fun_p(x):
          if (isinstance(x, types.LambdaType) or
              isinstance(x, types.MethodType)):
              return True
          elif (isinstance(x, types.BuiltinFunctionType) or
                isinstance(x, types.BuiltinMethodType)):
              if get_signature(x) == None:
                  return False
              else:
                  return True
          else:
              return False
      #+end_src

***** method_p

      #+begin_src python
      def method_p(x):
          if isinstance(x, types.MethodType):
              return True
          elif isinstance(x, types.BuiltinMethodType):
              if get_signature(x) == None:
                  return False
              else:
                  return True
          else:
              return False
      #+end_src

***** class_p

      #+begin_src python
      def class_p(x):
          if not inspect.isclass(x):
              return False
          elif x == type:
              return False
          else:
              return True
      #+end_src

***** Vect

      #+begin_src python
      Vect = list
      #+end_src

***** vect_p

      #+begin_src python
      def vect_p(x):
          return type(x) == Vect
      #+end_src

***** string_p

      #+begin_src python
      def string_p(x):
          return type(x) == str
      #+end_src

***** fill_vect

      #+begin_src python
      def fill_vect(value, length):
          vect = []
          i = 0
          while i < length:
              vect.append(value)
              i = i + 1
          return vect
      #+end_src

***** fill_tuple

      #+begin_src python
      def fill_tuple(value, length):
          return tuple(fill_vect(value, length))
      #+end_src

*** error handling

***** JOJO_ERROR

      #+begin_src python
      class JOJO_ERROR(Exception):
          pass
      #+end_src

***** error

      #+begin_src python
      def error():
          raise JOJO_ERROR()
      #+end_src

* vm

*** RP

    #+begin_src python
    class RP:
        def __init__(self, jojo):
            self.cursor = 0
            self.length = jojo.length
            self.body = jojo.body
            self.lr = jojo.lr.copy()
    #+end_src

*** VM

    #+begin_src python
    class VM:
        def __init__(self, ds, rs):
            self.ds = ds
            self.rs = rs

        def exe(self):
            length = len(self.rs)
            while len(self.rs) >= length:
                self.exe_one_step()
            return self

        def exe_one_step(self):
            rp = self.rs.pop()
            # handle empty closure
            if rp.length == 0:
                # one rp is finished
                return
            # get current jo
            jo = rp.body[rp.cursor]
            # handle tail call
            if rp.cursor >= rp.length - 1:
                # dispatching
                exe_jo(jo, rp, self)
                # one rp is finished
                return
            else:
                rp.cursor = rp.cursor + 1
                self.rs.append(rp)
                # dispatching
                exe_jo(jo, rp, self)
    #+end_src

*** VALUES

    #+begin_src python
    class VALUES:
        def __init__(self, *values):
            self.values = values
    #+end_src

*** exe_jo

    #+begin_src python
    def exe_jo(jo, rp, vm):
        if fun_p(jo):
            exe_fun(jo, vm)
        elif hasattr(jo, "jo_exe"):
            jo.jo_exe(rp, vm)
        else:
            vm.ds.append(jo)
    #+end_src

*** exe_fun

***** [note] python funtion arguments

      - normal arguments are called positional arguments.

      - there are also keyword-only arguments,
        because after *args,
        the information about position will be lost.

      - before *args
        each positional arguments took one position
        do not respect default arguments

        - to respect default arguments
          one has to use (call)

      - if *args is used in a function signature
        pass it as a vect

      - if **kwargs is used in a function signature
        pass it as a dict

***** exe_fun

      #+begin_src python
      def exe_fun(fun, vm):
          signature = get_signature(fun)

          if signature == None:
              print("- exe_fun fail to get signature")
              print("  fun : {}".format(fun))
              error()

          parameters = signature.parameters

          if has_para_dict(parameters):
              arg_dict = get_default_arg_dict(parameters)
              top_of_ds = vm.ds.pop()
              if not isinstance(top_of_ds, dict):
                  print("- exe_fun fail")
                  print("  when fun require a arg_dict")
                  print("  the top of data stack is not a dict")
                  print("  fun : {}".format(fun))
                  print("  top of data stack : {}".format(top_of_ds))
                  error()
              arg_dict.update(top_of_ds)
          else:
              arg_dict = None

          if has_para_vect(parameters):
              top_of_ds = vm.ds.pop()
              if not vect_p(top_of_ds):
                  print("- exe_fun fail")
                  print("  when fun require a arg_vect")
                  print("  the top of data stack is not a vect")
                  print("  fun : {}".format(fun))
                  print("  top of data stack : {}".format(top_of_ds))
                  error()
              arg_vect = top_of_ds
          else:
              arg_vect = []

          positional_para_length = get_positional_para_length(parameters)
          args = []
          i = 0
          while i < positional_para_length:
              args.append(vm.ds.pop())
              i = i + 1
          args.reverse()
          args.extend(arg_vect)

          if arg_dict == None:
              result = fun(*args)
          else:
              result = fun(*args, **arg_dict)

          push_result_to_vm(result, vm)
      #+end_src

***** push_result_to_vm

      #+begin_src python
      def push_result_to_vm(result, vm):
          if type(result) == VALUES:
              vm.ds.extend(result.values)
          elif result == None:
              return
          else:
              vm.ds.append(result)
      #+end_src

***** get_positional_para_length

      #+begin_src python
      def get_positional_para_length(parameters):
          n = 0
          for v in parameters.values():
              if (v.kind == inspect.Parameter.POSITIONAL_ONLY or
                  v.kind == inspect.Parameter.POSITIONAL_OR_KEYWORD):
                  n = n + 1
          return n
      #+end_src

***** has_para_vect

      #+begin_src python
      def has_para_vect(parameters):
          for v in parameters.values():
              if (v.kind == inspect.Parameter.VAR_POSITIONAL):
                  return True
          return False
      #+end_src

***** has_para_dict

      #+begin_src python
      def has_para_dict(parameters):
          for v in parameters.values():
              if (v.kind == inspect.Parameter.KEYWORD_ONLY or
                  v.kind == inspect.Parameter.VAR_KEYWORD):
                  return True
          return False
      #+end_src

***** get_default_arg_dict

      #+begin_src python
      def get_default_arg_dict(parameters):
          default_dict = {}
          for v in parameters.values():
              if (v.kind == inspect.Parameter.KEYWORD_ONLY and
                  v.default != inspect.Parameter.empty):
                  default_dict[v.name] = v.default
          return default_dict
      #+end_src

***** get_positional_default_arg_dict

      #+begin_src python
      def get_positional_default_arg_dict(parameters):
          default_dict = {}
          for v in parameters.values():
              if ((v.kind == inspect.Parameter.POSITIONAL_ONLY or
                   v.kind == inspect.Parameter.POSITIONAL_OR_KEYWORD)
                  and v.default != inspect.Parameter.empty):
                  default_dict[v.name] = v.default
          return default_dict
      #+end_src

*** jo -- in rp of return-stack

***** JOJO

      #+begin_src python
      class JOJO:
          def __init__(self, body):
              self.length = len(body)
              self.body = Vect(body)
              self.lr = {}

          def jo_exe(self, rp, vm):
              vm.rs.append(RP(self))

          def __repr__(self):
              if self.length == 0:
                  return "{}"
              rep_vect = []
              rep_vect.append("{")
              for jo in self.body[:-1]:
                  rep_vect.append(jo.__repr__())
                  rep_vect.append(" ")
              jo = self.body[-1]
              rep_vect.append(jo.__repr__())
              rep_vect.append("}")
              return "".join(rep_vect)
      #+end_src

***** CLO

      #+begin_src python
      class CLO:
          def __init__(self, body):
              self.body = body

          def jo_exe(self, rp, vm):
              new_jojo = JOJO(self.body)
              new_jojo.lr = rp.lr
              vm.ds.append(new_jojo)

          def __repr__(self):
              if len(self.body) == 0:
                  return "(clo)"
              rep_vect = []
              rep_vect.append("(clo ")
              for jo in self.body[:-1]:
                  rep_vect.append(jo.__repr__())
                  rep_vect.append(" ")
              jo = self.body[-1]
              rep_vect.append(jo.__repr__())
              rep_vect.append(")")
              return "".join(rep_vect)
      #+end_src

***** APPLY

      #+begin_src python
      class APPLY:
          @classmethod
          def jo_exe(self, rp, vm):
              clo = vm.ds.pop()
              clo.jo_exe(rp, vm)

          @classmethod
          def __repr__(self):
              return "apply"
      #+end_src

***** IFTE

      #+begin_src python
      class IFTE:
          @classmethod
          def jo_exe(self, rp, vm):
              clo2 = vm.ds.pop()
              clo1 = vm.ds.pop()
              test = vm.ds.pop()
              if test:
                  vm.rs.append(RP(clo1))
              else:
                  vm.rs.append(RP(clo2))

          @classmethod
          def __repr__(self):
              return "ifte"
      #+end_src

***** CALL_FROM_MODULE

      #+begin_src python
      class CALL_FROM_MODULE:
          def __init__(self, module_name, name):
              self.module_name = module_name
              self.name = name

          def jo_exe(self, rp, vm):
              module = sys.modules[self.module_name]
              jo = getattr(module, self.name)
              exe_jo(jo, rp, vm)

          def __repr__(self):
              # "(call {} from {})".format(self.name, self.module.__name__)
              return self.name
      #+end_src

***** GET

      #+begin_src python
      class GET:
          def __init__(self, name):
              self.name = name

          def jo_exe(self, rp, vm):
              data = rp.lr[self.name]
              vm.ds.append(data)

          def __repr__(self):
              return self.name
      #+end_src

***** SET

      #+begin_src python
      class SET:
          def __init__(self, name):
              self.name = name

          def jo_exe(self, rp, vm):
              value = vm.ds.pop()
              rp.lr[self.name] = value

          def __repr__(self):
              return self.name + '!'
      #+end_src

***** MARK -- for collectors

      #+begin_src python
      class MARK:
          @classmethod
          def jo_exe(self, rp, vm):
              vm.ds.append(self)

          @classmethod
          def __repr__(self):
              return "mark"
      #+end_src

***** COLLECT_VECT -- collect values before mark to vect

      #+begin_src python
      class COLLECT_VECT:
          @classmethod
          def jo_exe(self, rp, vm):
              vect = []
              while True:
                  value = vm.ds.pop()
                  if value == MARK:
                      break
                  else:
                      vect.append(value)
              vect.reverse()
              vm.ds.append(vect)

          @classmethod
          def __repr__(self):
              return "collect-vect"
      #+end_src

***** VECT_SPREAD -- spread values to data stack

      #+begin_src python
      class VECT_SPREAD:
          @classmethod
          def jo_exe(self, rp, vm):
              vect = vm.ds.pop()
              for value in vect:
                  vm.ds.append(value)

          @classmethod
          def __repr__(self):
              return "vect-spread"
      #+end_src

***** COLLECT_LIST -- collect values before mark to list

      #+begin_src python
      class COLLECT_LIST:
          @classmethod
          def jo_exe(self, rp, vm):
              def recur(rest):
                  value = vm.ds.pop()
                  if value == MARK:
                      return rest
                  else:
                      return recur(cons(value, rest))
              vm.ds.append(recur(null))

          @classmethod
          def __repr__(self):
              return "collect-list"
      #+end_src

***** LIST_SPREAD -- spread values to data stack

      #+begin_src python
      class LIST_SPREAD:
          @classmethod
          def jo_exe(self, rp, vm):
              def recur(l):
                  if null_p(l):
                      pass
                  else:
                      vm.ds.append(car(l))
                      recur(cdr(l))
              recur(vm.ds.pop())

          @classmethod
          def __repr__(self):
              return "list-spread"
      #+end_src

***** DATA_PRED -- for data predicate

      #+begin_src python
      class DATA_PRED:
          def __init__(self, data_class):
              self.data_class = data_class

          def jo_exe(self, rp, vm):
              x = vm.ds.pop()
              vm.ds.append(type(x) == self.data_class)

          def __repr__(self):
              return data_class.__name__ + '?'
      #+end_src

***** NEW -- create object from data and class

      #+begin_src python
      class NEW:
          @classmethod
          def jo_exe(self, rp, vm):
              x = vm.ds.pop()
              if not class_p(x):
                  print("- NEW.jo_exe fail")
                  print("  argument is not a class : {}".format(x))
                  error()
              else:
                  exe_fun(x, vm)

          @classmethod
          def __repr__(self):
              return "new"
      #+end_src

***** MSG -- message to object

      #+begin_src python
      class MSG:
          def __init__(self, message):
              self.message = message

          def jo_exe(self, rp, vm):
              o = vm.ds.pop()
              v = getattr(o, self.message)
              if method_p(v):
                  exe_fun(v, vm)
              else:
                  exe_jo(v, rp, vm)

          def __repr__(self):
              return "." + self.message
      #+end_src

***** SET_FIELD

      #+begin_src python
      class SET_FIELD:
          def __init__(self, field_name):
              self.field_name = field_name

          def jo_exe(self, rp, vm):
              o = vm.ds.pop()
              v = vm.ds.pop()
              setattr(o, self.field_name, v)

          def __repr__(self):
              return "." + self.field_name + "!"
      #+end_src

***** GENE

      #+begin_src python
      class GENE:
          def __init__(self, arity, default_jojo):
              self.arity = arity
              self.default_jojo = default_jojo
              self.disp_dict = {}

          def jo_exe(self, rp, vm):
              value_vect = vm.ds[(- self.arity):]
              type_vect = []
              for value in value_vect:
                  type_vect.append(type(value))

              type_tuple = tuple(type_vect)
              if type_tuple in self.disp_dict:
                  jojo = self.disp_dict[type_tuple]
                  jojo.jo_exe(rp, vm)
              else:
                  self.default_jojo.jo_exe(rp, vm)
      #+end_src

***** CLEAR

      #+begin_src python
      class CLEAR:
          @classmethod
          def jo_exe(self, rp, vm):
              vm.ds = []

          @classmethod
          def __repr__(self):
              return "clear"
      #+end_src

***** PRIMITIVE

      #+begin_src python
      class PRIMITIVE:
          def __init__(self, fun):
              self.fun = fun

          def jo_exe(self, rp, vm):
              vm.ds.append(self.fun)

          def __repr__(self):
              return self.fun
      #+end_src

* >< actor

*** [note] limitation

    - can not send module as message

*** [note] scheduler loop

***** preparing

      1. handle meta-message
         about actor creation and linking.

      2. send out messages in out_queue to queue_vect.

      3. distribute messages in in_queue to actors,
         if an actor is in waiting_set,
         awake it.

***** processing

      1. process the active_queue in a round-robin manner,
         until it has only one actor.

         - when there is only one actor,
           no scheduling is needed.

      2. process the last actor,
         and loop back.

*** [note] process_actors -- the round-robin working horse

    1. if an actor exits,
       the scheduler delet it from the actor_dict.

    2. if an actor want to receive a message,
       but its message queue is empty,
       it will be droped from the active_queue.

       - it is still in the actor_dict,
         and in next round,
         if there are messages sent to it,
         it will eventually be added to
         the active_queue again.

    3. if an actor want to send a message,
       the scheduler put the message in the out_queue.

    4. if an actor want to create a new actor,
       a meta-message will be sent to its scheduler.

*** [note] actor-creation & meta-message

    - note that, actor-creation returns actor-id.
      since the newly created actor
      will be allocated to schedulers randomly,
      actor-creation might blocks.

    - thus, we send a meta-message
      about actor-creation
      to current scheduler
      and drop this actor from active_queue,
      and add it to spawning_set.

    - all actor-creation [all meta-message] will be handled
      in the next round of the scheduler.

    - but the scheduler still has to wait for actor-creation,

      - thus a scheduler must maintain a fresh_actor_queue
        to receive newly created actors.

      - and a spawning_set of actors,
        actors in it will not be active,
        until the newly created actor is pushed to its data-stack.

    - meta-message can be used
      to achieve more then actor-creation.

      - linking actors ><><><

      - ><><>< more

*** [note] scheduling

    - round-robin

    - pre-emptive by execution steps

    - interrupt on special cases :
      1. message sending
      2. actor-creation

*** [note] message & actor-id

    - a message contains two fields,
      actor-id and message-body.

    - actor-id
      sid uni-id

*** [note] actor address security

    - when embedded in python
      I can not prevent an evil actor
      to create actor-id dynamicly and send messages to them.

      how is erlang coping with this ?
      erlang can use c but, is it really safe on this ?

    - if actor-id (erlang pid) is not safe,
      we might use something which is
      more close to actor model's notion of address,
      we can separate public address
      from non-public address.

    - how about IPC and system pid ?

*** Aid -- actor id

    #+begin_src python
    class Aid:
        def __init__(self, sid, key):
            self.sid = sid # natural number
            self.key = key
        def __eq__(self, other):
            return (self.sid == other.sid and
                    self.key == other.key)
        def __hash__(self):
            return hash((self.sid, self.key))
        def __repr__(self):
            return "<aid:(sid:{}, key:{})>" \
                .format(self.sid, self.key)
    #+end_src

*** Actor

    #+begin_src python
    class Actor:
        def __init__(self, scheduler, vm):
            self.scheduler = scheduler
            self.vm = vm
            self.ds = vm.ds
            self.rs = vm.rs
            self.mq = queue.Queue()
            self.aid = generate_aid(scheduler)
            scheduler.actor_dict[self.aid.key] = self
            scheduler.active_queue.put(self)

        def finished_p(self):
            return len(self.rs) == 0

        def exe_one_step(self):
            rp = self.rs.pop()
            # handle empty closure
            if rp.length == 0:
                # one rp is finished
                return
            # get current jo
            jo = rp.body[rp.cursor]
            # handle tail call
            if rp.cursor >= rp.length - 1:
                # dispatching
                act_jo(jo, rp, self)
                # one rp is finished
                return
            else:
                rp.cursor = rp.cursor + 1
                self.rs.append(rp)
                # dispatching
                act_jo(jo, rp, self)
    #+end_src

*** generate_aid

    #+begin_src python
    def generate_aid(scheduler):
        sid = scheduler.sid
        key = scheduler._actor_counter
        scheduler._actor_counter = key + 1
        return Aid(sid, key)
    #+end_src

*** act_jo

    #+begin_src python
    def act_jo(jo, rp, actor):
        if hasattr(jo, "jo_act"):
            jo.jo_act(rp, actor)
        else:
            exe_jo(jo, rp, actor)
            actor.scheduler.active_queue.put(actor)
    #+end_src

*** jo for actor

***** [note]

      - 'jo_act' for exe in scheduler
      - 'jo_exe' for sequential exe

***** RECEIVE

      #+begin_src python
      class RECEIVE:
          @classmethod
          def jo_act(self, rp, actor):
              if not actor.mq.empty():
                  value = actor.mq.get()
                  actor.ds.append(value)
                  actor.scheduler.active_queue.put(actor)
              else:
                  actor.scheduler.waiting_set.add(actor.aid)
                  # do not put the actor back to active_queue

          @classmethod
          def jo_exe(self, rp, vm):
              print("- receive fail")
              print("  can not use 'receive' in sequential code")
              error()

          @classmethod
          def __repr__(self):
              return "receive"
      #+end_src

***** SEND

      #+begin_src python
      class SEND:
          @classmethod
          def jo_act(self, rp, actor):
              body = actor.ds.pop()
              aid = actor.ds.pop()
              message = Message(aid, body)
              sche = actor.scheduler
              sche.out_queue.put(message)
              sche.active_queue.put(actor)

          @classmethod
          def jo_exe(self, rp, vm):
              print("- send fail")
              print("  can not use 'send' in sequential code")
              error()

          @classmethod
          def __repr__(self):
              return "send"
      #+end_src

***** SPAWN

      #+begin_src python
      class SPAWN:
          @classmethod
          def jo_act(self, rp, actor):
              clo = actor.ds.pop()
              meta_message = MetaMessage("spawn", {
                  'aid' : actor.aid,
                  'clo' : clo,
              })
              actor.scheduler.meta_out_queue.put(meta_message)
              actor.scheduler.spawning_set.add(actor.aid)
              # do not put the actor back to active_queue

          @classmethod
          def jo_exe(self, rp, vm):
              print("- spawn fail")
              print("  can not use 'spawn' in sequential code")
              error()

          @classmethod
          def __repr__(self):
              return "spawn"
      #+end_src

***** ACTION

      #+begin_src python
      class ACTION:
          @classmethod
          def jo_exe(self, rp, vm):
              clo = vm.ds.pop()
              random_sid = generate_random_sid()
              channel = global_channel_vect[random_sid]
              meta_message = MetaMessage("action", {
                  'clo'  : clo,
              })
              channel.meta_in_queue.put(meta_message)

          @classmethod
          def __repr__(self):
              return "action"
      #+end_src

*** Channel

    #+begin_src python
    class Channel:
        def __init__(self):
            self.in_queue = mp.Queue()
            self.meta_in_queue = mp.Queue()
    #+end_src

*** MetaMessage

    - an actor can send MetaMessage
      to its own scheduler.

    #+begin_src python
    class MetaMessage:
        def __init__(self, head, body):
            self.head = head
            self.body = body
    #+end_src

*** Scheduler

***** Scheduler

      #+begin_src python
      class Scheduler:
          def __init__(self, channel_vect, sid):
              self.sid = sid
              self.channel_vect = channel_vect

              self.channel = self.channel_vect[sid]
              self.in_queue = self.channel.in_queue
              self.meta_in_queue = self.channel.meta_in_queue

              self.out_queue = queue.Queue()
              self.meta_out_queue = queue.Queue()

              self.active_queue = queue.Queue()
              self.actor_dict = dict()
              self.waiting_set = set() # of aid
              self.spawning_set = set() # of aid

              self._actor_counter = 0
      #+end_src

***** sche_start

      #+begin_src python
      def sche_start(sche):
          while True:
              send_meta_out_queue(sche)
              process_meta_in_queue(sche)
              send_out_queue(sche)
              distribute_in_queue(sche)
              schedule(sche)
      #+end_src

***** send_meta_out_queue

      #+begin_src python
      def send_meta_out_queue(sche):
          while not sche.meta_out_queue.empty():
              meta_message = sche.meta_out_queue.get()
              if meta_message.head == "spawn":
                  meta_request = MetaMessage("spawn-request", {
                      'aid' : meta_message.body['aid'],
                      'clo' : meta_message.body['clo'],
                  })
                  random_sid = generate_random_sid()
                  random_channel = sche.channel_vect[random_sid]
                  random_channel.meta_in_queue.put(meta_request)
      #+end_src

***** process_meta_in_queue

      #+begin_src python
      def process_meta_in_queue(sche):
          while not sche.meta_in_queue.empty():
              meta_message = sche.meta_in_queue.get()

              if meta_message.head == "spawn-request":
                  old_aid = meta_message.body['aid']
                  clo = meta_message.body['clo']
                  jojo = JOJO(clo.body)
                  rp = RP(jojo)
                  vm = VM([], [rp])
                  actor = Actor(sche, vm)
                  new_aid = actor.aid
                  meta_response = MetaMessage("spawn-response", {
                      'old_aid' : old_aid,
                      'new_aid' : new_aid,
                  })
                  channel = sche.channel_vect[old_aid.sid]
                  channel.meta_in_queue.put(meta_response)

              elif meta_message.head == "spawn-response":
                  old_aid = meta_message.body['old_aid']
                  new_aid = meta_message.body['new_aid']
                  old_actor = sche.actor_dict[old_aid.key]
                  if old_aid in sche.spawning_set:
                      sche.spawning_set.remove(old_aid)
                      sche.active_queue.put(old_actor)
                      old_actor.ds.append(new_aid)
                  else:
                      print("- spawn-response sent to wrong actor")
                      error()

              elif meta_message.head == "action":
                  clo = meta_message.body['clo']
                  jojo = JOJO(clo.body)
                  rp = RP(jojo)
                  vm = VM([], [rp])
                  actor = Actor(sche, vm)
      #+end_src

***** send_out_queue

      #+begin_src python
      def send_out_queue(sche):
          while not sche.out_queue.empty():
              message = sche.out_queue.get()
              channel = sche.channel_vect[message.aid.sid]
              channel.in_queue.put(message)

      #+end_src

***** distribute_in_queue

      #+begin_src python
      def distribute_in_queue(sche):
          while not sche.in_queue.empty():
              message = sche.in_queue.get()
              actor = sche.actor_dict[message.aid.key]
              if actor.aid in sche.waiting_set:
                  sche.waiting_set.remove(actor.aid)
                  sche.active_queue.put(actor)
                  actor.ds.append(message.body)
              else:
                  actor.mq.put(message.body)
      #+end_src

***** schedule

      #+begin_src python
      def schedule(sche):
          i = 0
          qsize = sche.active_queue.qsize()
          while i < qsize:
              actor = sche.active_queue.get()
              if actor.finished_p():
                  del sche.actor_dict[actor.aid.key]
              else:
                  actor.exe_one_step()
              i = i + 1
      #+end_src

*** Message

    #+begin_src python
    class Message:
        def __init__(self, aid, body):
            self.aid = aid
            self.body = body
    #+end_src

*** SCHE_NUMBER

    #+begin_src python
    SCHE_NUMBER = mp.cpu_count()
    #+end_src

*** generate_random_sid

    #+begin_src python
    def generate_random_sid():
        return random.randint(0, SCHE_NUMBER - 1)
    #+end_src

*** global_channel_vect

    #+begin_src python
    global_channel_vect = []
    for i in range(SCHE_NUMBER):
        global_channel_vect.append(Channel())
    #+end_src

*** global_scheduler_vect

    #+begin_src python
    global_scheduler_vect = []
    for i in range(SCHE_NUMBER):
        scheduler = Scheduler(global_channel_vect, i)
        global_scheduler_vect.append(scheduler)
    #+end_src

*** global_process_vect

    #+begin_src python
    global_process_vect = []
    for scheduler in global_scheduler_vect:
        process = mp.Process(
            target = sche_start,
            args = [scheduler],
            daemon = True
        )
        global_process_vect.append(process)
    #+end_src

*** schedule_start

    #+begin_src python
    def schedule_start():
        for process in global_process_vect:
            process.start()
    #+end_src

* scan -- lexer for sexp

*** code_scan

    - ';' as line comment

    #+begin_src python
    def code_scan(string):
        string_vect = []
        i = 0
        length = len(string)
        while i < length:
            char = string[i]

            if space_p(char):
                i = i + 1

            elif char == ';':
                newline_index = string.find('\n', i+1)
                if newline_index == -1:
                    break
                end = newline_index + 1
                i = end

            elif delimiter_p(char):
                string_vect.append(char)
                i = i + 1

            elif doublequote_p(char):
                doublequote_end_index = string.find('"', i+1)
                if doublequote_end_index == -1:
                    print("- code_scan fail")
                    print("  doublequote mismatch")
                    print("  string : {}".format(string))
                    error()
                end = doublequote_end_index + 1
                string_vect.append(string[i:end])
                i = end

            else:
                end = find_end(string, i+1)
                string_vect.append(string[i:end])
                i = end

        return string_vect
    #+end_src

*** find_end

    #+begin_src python
    def find_end(string, begin):
        length = len(string)
        i = begin
        while True:
           if i == length:
               return i
           char = string[i]
           if (space_p(char) or
               delimiter_p(char) or
               doublequote_p(char)):
               return i
           i = i + 1
    #+end_src

*** space_p

    #+begin_src python
    def space_p(char):
        return char.isspace()
    #+end_src

*** delimiter_p

    #+begin_src python
    def delimiter_p(char):
        return (char == '(' or
                char == ')' or
                char == '[' or
                char == ']' or
                char == '{' or
                char == '}' or
                char == ',' or
                char == ';' or
                char == '`' or
                char == "'")
    #+end_src

*** doublequote_p

    #+begin_src python
    def doublequote_p(char):
        return char == '"'
    #+end_src

* sexp -- string expression

*** null & cons

***** Null

      #+begin_src python
      class Null:
          pass
      #+end_src

***** null

      #+begin_src python
      null = Null()
      #+end_src

***** null_p

      #+begin_src python
      def null_p(x):
          return x == null
      #+end_src

***** Cons

      #+begin_src python
      class Cons:
          def __init__(self, car, cdr):
              self.car = car
              self.cdr = cdr
      #+end_src

***** cons

      #+begin_src python
      def cons(car, cdr):
          if null_p(cdr) or cons_p(cdr):
              return Cons(car, cdr)
          else:
              print("- cons fail")
              print("  cdr of cons must be a cons or null")
              print("  cdr : {}".format(cdr))
              error()
      #+end_src

***** cons_p

      #+begin_src python
      def cons_p(x):
          return isinstance(x, Cons)
      #+end_src

***** cdr

      #+begin_src python
      def cdr(x):
          return x.cdr
      #+end_src

***** car

      #+begin_src python
      def car(x):
          return x.car
      #+end_src

*** [note] syntax sugar

    - [...] -> (begin ...)
    - {...} -> (clo ...)
    - ' ... -> (quote ...)
    - ` ... -> (partquote ...)

*** parse_sexp_vect -- string vect to sexp vect

    - sexp := Null | Cons(sexp, sexp_list) | string

    #+begin_src python
    def parse_sexp_vect(string_vect):
        length = len(string_vect)
        i = 0
        sexp_vect = []
        while i < length:
           s, i = parse_sexp(string_vect, i)
           sexp_vect.append(s)
        return sexp_vect
    #+end_src

*** parse_sexp

    #+begin_src python
    def parse_sexp(string_vect, i):
        string = string_vect[i]
        if string == '(':
            return parse_sexp_cons_until_ket(string_vect, i+1, ')')
        elif string == '[':
            s_cons, i1 = parse_sexp_cons_until_ket(string_vect, i+1, ']')
            return (cons('begin', s_cons), i1)
        elif string == '{':
            s_cons, i1 = parse_sexp_cons_until_ket(string_vect, i+1, '}')
            return (cons('clo', s_cons), i1)
        elif string == "'":
            s, i1 = parse_sexp(string_vect, i+1)
            return (cons('quote', cons(s, null)), i1)
        elif string == "`":
            s, i1 = parse_sexp(string_vect, i+1)
            return (cons('partquote', cons(s, null)), i1)
        else:
            return (string, i+1)
    #+end_src

*** parse_sexp_cons_until_ket

    #+begin_src python
    def parse_sexp_cons_until_ket(string_vect, i, ket):
        string = string_vect[i]
        if string == ket:
            return (null, i+1)
        else:
            s, i1 = parse_sexp(string_vect, i)
            s_cons, i2 = \
                parse_sexp_cons_until_ket(string_vect, i1, ket)
            return (cons(s, s_cons), i2)
    #+end_src

*** p_print

    #+begin_src python
    def p_print(x):
        print(x, end="")
        sys.stdout.flush()
    #+end_src

*** sexp_print

    #+begin_src python
    def sexp_print(s):
        if null_p(s):
            p_print("null")
        elif cons_p(s):
            p_print("(")
            sexp_list_print(s)
            p_print(")")
        else:
            p_print(s)
    #+end_src

*** sexp_list_print

    #+begin_src python
    def sexp_list_print(s_cons):
        if null_p(s_cons):
            pass
        elif null_p(cdr(s_cons)):
            sexp_print(car(s_cons))
        else:
            sexp_print(car(s_cons))
            p_print(" ")
            sexp_list_print(cdr(s_cons))
    #+end_src

* compiler

*** [note]

    - 'new_module'
      - create new module
      - setup required attrs
      - register the module to sys.modules
      called by 'compile_module' and 'compile_core_module'

    - 'merge_module'
      - merge 'jojo_define'-d name in .defined_name_set
        to another module

    - 'merge_sexp_vect'
      - merge a vect of sexp to module
      called by compilers and repls

*** new_module

    #+begin_src python
    def new_module(name):
        module = types.ModuleType(name)
        # for top level sexp
        module.vm = VM([], [])
        # for name can occur before been defined
        module.defined_name_set = set()
        # do not override import cache
        if name in sys.modules:
            print('- new_module fail')
            print('  can not override import cache')
            print('  [import cache is sys.modules]')
            print('  name : {}'.format(name))
            error()
        sys.modules[name] = module
        return module
    #+end_src

*** jojo_define

    #+begin_src python
    def jojo_define(module, name, value):
        module.defined_name_set.add(name)
        setattr(module, name, value)
    #+end_src

*** merge_prim_dict

    #+begin_src python
    def merge_prim_dict(module):
        for name, value in prim_dict.items():
            jojo_define(module, name, value)
    #+end_src

*** merge_module

    #+begin_src python
    def merge_module(module, src_module):
        for name in src_module.defined_name_set:
            jojo = getattr(src_module, name)
            jojo_define(module, name, jojo)
    #+end_src

*** merge_sexp_vect

    - a module has its vm,
      which is used to eval top level sexps.

    #+begin_src python
    def merge_sexp_vect(module, sexp_vect):
        for sexp in sexp_vect:
            jo_vect = sexp_emit(module, sexp)
            module.vm.rs.append(RP(JOJO(jo_vect)))
            module.vm.exe()
        return module
    #+end_src

*** compile_module

    #+begin_src python
    def compile_module(name, sexp_vect):
        module = new_module(name)
        merge_prim_dict(module)
        merge_module(module, core_module)
        merge_sexp_vect(module, sexp_vect)
        return module
    #+end_src

*** compile_core_module

    - compile the core_module itself
      without merging core_module

    #+begin_src python
    def compile_core_module(name, sexp_vect):
        module = new_module(name)
        merge_prim_dict(module)
        merge_sexp_vect(module, sexp_vect)
        return module
    #+end_src

*** sexp_list_emit

    #+begin_src python
    def sexp_list_emit(module, sexp_list):
        jo_vect = []
        while not null_p(sexp_list):
            sexp = car(sexp_list)
            jo_vect.extend(sexp_emit(module, sexp))
            sexp_list = cdr(sexp_list)
        return jo_vect
    #+end_src

*** sexp_emit

***** sexp_emit

      #+begin_src python
      def sexp_emit(module, sexp):
          if null_p(sexp):
              return null_emit(module, sexp)
          elif cons_p(sexp):
              return cons_emit(module, sexp)
          else:
              return string_emit(module, sexp)
      #+end_src

***** null_emit

      #+begin_src python
      def null_emit(module, sexp):
          return [null]
      #+end_src

***** cons_emit

      #+begin_src python
      def cons_emit(module, cons):
          keyword = car(cons)
          # keyword can not have dot-in-name
          if keyword in keyword_dict.keys():
              fun = keyword_dict[keyword]
              return fun(module, cdr(cons))
          elif keyword in macro_dict.keys():
              fun = macro_dict[keyword]
              new_sexp = fun(cdr(cons))
              return sexp_emit(module, new_sexp)
          else:
              # a call to string_emit
              # handles dot-in-name in head of sexp
              vm = VM([cdr(cons)],
                      [RP(JOJO(string_emit(module, keyword)))])
              vm.exe()
              new_sexp = vm.ds[0]
              return sexp_emit(module, new_sexp)
      #+end_src

***** string_emit

      #+begin_src python
      def string_emit(module, string):
          # special strings
          for p, e in string_emitter_vect:
              if p(string):
                  return e(module, string)

          # dot in string
          if '.' in string:
              return dot_in_string_emit(module, string)

          # built-in keyword
          if string in key_jo_dict.keys():
              return key_jo_dict[string]

          # normal function call
          return [CALL_FROM_MODULE(module.__name__, string)]
      #+end_src

***** dot_in_string_emit

      #+begin_src python
      def dot_in_string_emit(module, string):
          jo_vect = []
          string_vect = string.split('.')
          head_string = string_vect[0]
          if head_string == '':
              pass
          else:
              jo_vect.extend(string_emit(module, head_string))

          tail_string_vect = string_vect[1:]
          for s in tail_string_vect:
              s1 = '.' + s
              jo_vect.extend(string_emit(module, s1))

          return jo_vect
      #+end_src

***** string_emitter_vect & @string_emitter

******* string_emitter_vect

        - vect is used,
          for the order matters.

        #+begin_src python
        string_emitter_vect = []
        #+end_src

******* @string_emitter

        #+begin_src python
        def string_emitter(p):
            def decorator(emitter):
                string_emitter_vect.append((p, emitter))
                return emitter
            return decorator
        #+end_src

******* int_string_p

        #+begin_src python
        def int_string_p(string):
            if not string_p(string):
                return False
            length = len(string)
            if length == 0:
                return False
            elif string[0] == '-':
                return nat_string_p(string[1:])
            else:
                return nat_string_p(string)
        #+end_src

******* nat_string_p

        #+begin_src python
        def nat_string_p(string):
            if not string_p(string):
                return False
            return string.isdecimal()
        #+end_src

******* int_string_emitter

        #+begin_src python
        @string_emitter(int_string_p)
        def int_string_emitter(module, string):
            return [int(string)]
        #+end_src

******* doublequoted_string_p

        - "doublequoted"

        #+begin_src python
        def doublequoted_string_p(string):
            if not string_p(string):
                return False
            if len(string) < 2:
                return False
            elif string[0] != '"':
                return False
            elif string[-1] != '"':
                return False
            else:
                return True
        #+end_src

******* doublequoted_string_emitter

        #+begin_src python
        @string_emitter(doublequoted_string_p)
        def doublequoted_string_emitter(module, string):
            string = string[1:-1]
            return [string]
        #+end_src

******* local_string_p

        - :local

        #+begin_src python
        def local_string_p(string):
            if not string_p(string):
                return False
            if len(string) < 2:
                return False
            elif string.count('.') != 0:
                return False
            elif string.count(':') != 1:
                return False
            elif string[0] != ':':
                return False
            elif string[-1] == '!':
                return False
            else:
                return True
        #+end_src

******* local_string_emitter

        #+begin_src python
        @string_emitter(local_string_p)
        def local_string_emitter(module, string):
            return [GET(string)]
        #+end_src

******* set_local_string_p

        - :local!

        #+begin_src python
        def set_local_string_p(string):
            if not string_p(string):
                return False
            if len(string) < 3:
                return False
            elif string.count('.') != 0:
                return False
            elif string[0] != ':':
                return False
            elif string[-1] != '!':
                return False
            else:
                return True
        #+end_src

******* set_local_string_emitter

        #+begin_src python
        @string_emitter(set_local_string_p)
        def set_local_string_emitter(module, string):
            string = string[:-1]
            return [SET(string)]
        #+end_src

******* message_string_p

        - .message

        #+begin_src python
        def message_string_p(string):
            if not string_p(string):
                return False
            if len(string) < 2:
                return False
            elif string[0] != '.':
                return False
            elif string.count('.') != 1:
                return False
            elif string[-1] == '!':
                return False
            else:
                return True
        #+end_src

******* message_string_emitter

        #+begin_src python
        @string_emitter(message_string_p)
        def message_string_emitter(module, string):
            string = string[1:]
            return [MSG(string)]
        #+end_src

******* set_message_string_p

        - .message!

        #+begin_src python
        def set_message_string_p(string):
            if not string_p(string):
                return False
            if len(string) < 2:
                return False
            elif string[0] != '.':
                return False
            elif string.count('.') != 1:
                return False
            elif string[-1] != '!':
                return False
            else:
                return True
        #+end_src

******* set_message_string_emitter

        #+begin_src python
        @string_emitter(set_message_string_p)
        def set_message_string_emitter(module, string):
            string = string[1:-1]
            return [SET_FIELD(string)]
        #+end_src

* prim_dict

*** prim_dict & @prim

    #+begin_src python
    prim_dict = {}

    def prim(name):
        def decorator(fun):
            prim_dict[name] = fun
            return fun
        return decorator
    #+end_src

*** *stack operation*

    #+begin_src python
    @prim('drop')
    def drop(a):
        return None

    @prim('dup')
    def dup(a):
        return VALUES(a, a)

    @prim('over')
    def over(a, b):
        return VALUES(a, b, a)

    @prim('tuck')
    def tuck(a, b):
        return VALUES(b, a, b)

    @prim('swap')
    def swap(a, b):
        return VALUES(b, a)
    #+end_src

*** *int*

***** Int

      #+begin_src python
      Int = int
      prim('Int')(Int)
      #+end_src

***** int_p

      #+begin_src python
      @prim('int?')
      def int_p(x):
          return type(x) == int
      #+end_src

***** primary school

      #+begin_src python
      @prim('inc')
      def inc(a):
          return a + 1

      @prim('dec')
      def dec(a):
          return a - 1

      @prim('add')
      def add(a, b):
          return a + b

      @prim('sub')
      def sub(a, b):
          return a - b

      @prim('mul')
      def mul(a, b):
          return a * b

      @prim('div')
      def div(a, b):
          return a // b

      @prim('mod')
      def mod(a, b):
          return a % b

      @prim('divmod')
      def p_divmod(a, b):
          return VALUES(*divmod(a, b))
      #+end_src

***** compare

******* lt_p -- less then

        #+begin_src python
        @prim('lt?')
        def lt_p(a, b):
            return a < b
        #+end_src

******* gt_p -- greater then

        #+begin_src python
        @prim('gt?')
        def gt_p(a, b):
            return a > b
        #+end_src

******* lteq_p -- less then or equal to

        #+begin_src python
        @prim('lteq?')
        def lteq_p(a, b):
            return a <= b
        #+end_src

******* gteq_p -- greater then or equal to

        #+begin_src python
        @prim('gteq?')
        def gteq_p(a, b):
            return a >= b
        #+end_src

***** int_print

      #+begin_src python
      @prim('int-print')
      def int_print(i):
          p_print(i)
      #+end_src

*** *bool*

***** Bool

      #+begin_src python
      Bool = bool
      prim('Bool')(Bool)
      #+end_src

***** basic

      #+begin_src python
      @prim('true')
      def true():
          return True

      @prim('false')
      def false():
          return False

      @prim('not')
      def p_not(b):
          return not b

      @prim('and')
      def p_and(a, b):
          return (a and b)

      @prim('or')
      def p_or(a, b):
          return (a or b)
      #+end_src

*** *equivalence*

***** eq_p

      #+begin_src python
      @prim('eq?')
      def eq_p(a, b):
          if string_p(a):
              return a == b
          else:
              return a is b
      #+end_src

***** eqv_p

      #+begin_src python
      @prim('eqv?')
      def eqv_p(a, b):
          return a == b
      #+end_src

*** *sexp*

    #+begin_src python
    prim('null')(null)
    prim('null?')(null_p)

    prim('cons')(cons)
    prim('cons?')(cons_p)

    prim('car')(car)
    prim('cdr')(cdr)

    prim('sexp-print')(sexp_print)
    prim('sexp-list-print')(sexp_list_print)

    prim('code-scan')(code_scan)
    #+end_src

*** *string*

***** String

      #+begin_src python
      String = str
      prim('String')(String)
      #+end_src

***** string_p

      #+begin_src python
      prim('string?')(string_p)
      #+end_src

***** string_print

      #+begin_src python
      @prim('string-print')
      def string_print(string):
          p_print(string)
      #+end_src

***** string_length

      #+begin_src python
      @prim('string-length')
      def string_length(string):
          return len(string)
      #+end_src

***** string_ref

      #+begin_src python
      @prim('string-ref')
      def string_ref(string, index):
          return string[index]
      #+end_src

***** string_append

      #+begin_src python
      @prim('string-append')
      def string_append(string1, string2):
          return "".join([string1, string2])
      #+end_src

***** string_slice

      #+begin_src python
      @prim('string-slice')
      def string_slice(string, begin, end):
          return string[begin:end]
      #+end_src

***** string_empty_p

      #+begin_src python
      @prim('string-empty?')
      def string_empty_p(string):
          return len(string) == 0
      #+end_src

***** string_eq_p

      #+begin_src python
      @prim('string-eq?')
      def string_eq_p(string1, string2):
          return string1 == string2
      #+end_src

***** string_to_int

      #+begin_src python
      @prim('string->int')
      def string_to_int(string):
          return int(string)
      #+end_src

***** string predicates

      #+begin_src python
      prim('int-string?')(int_string_p)
      prim('local-string?')(local_string_p)
      #+end_src

*** *vect*

***** [note]

      - vect is the pivot among :
        - list
        - dict
        - tuple
        - set

***** Vect

      #+begin_src python
      prim('Vect')(Vect)
      #+end_src

***** vect_p

      #+begin_src python
      prim('vect?')(vect_p)
      #+end_src

***** vect_copy

      #+begin_src python
      @prim('vect-copy')
      def vect_copy(vect):
          return vect[:]
      #+end_src

***** vect_member_p

      #+begin_src python
      @prim('vect-member?')
      def vect_member_p(x, vect):
          return x in vect
      #+end_src

***** vect_length

      #+begin_src python
      @prim('vect-length')
      def vect_length(vect):
          return len(vect)
      #+end_src

***** vect_empty_p

      #+begin_src python
      @prim('vect-empty?')
      def vect_empty_p(vect):
          return len(vect) == 0
      #+end_src

***** vect_ref

      #+begin_src python
      @prim('vect-ref')
      def vect_ref(vect, index):
          return vect[index]
      #+end_src

***** vect_append -- no-side-effect

      #+begin_src python
      @prim('vect-append')
      def vect_append(vect1, vect2):
          vect1_copy = vect_copy(vect1)
          vect1_copy.extend(vect2)
          return vect1_copy
      #+end_src

***** vect_zip_dict

      #+begin_src python
      @prim('vect-zip-dict')
      def vect_zip_dict(v1, v2):
          if len(v1) != len(v2):
              print("- vect_zip_dict fail")
              print("  length of vect1")
              print("    is not equal to length of vect2")
              print("  length of vect1 : {}".format(len(v1)))
              print("  length of vect2 : {}".format(len(v2)))
              print("  vect1 : {}".format(v1))
              print("  vect2 : {}".format(v2))
              error()
          d = {}
          for k, v in zip(v1, v2):
             d[k] = v
          return d
      #+end_src

***** vect_to_sexp

      #+begin_src python
      @prim('vect->sexp')
      def vect_to_sexp(vect):
          if vect == []:
              return null
          elif not vect_p(vect):
              return vect
          else:
              return cons(vect_to_sexp(vect[0]),
                          vect_to_sexp(vect[1:]))
      #+end_src

***** sexp_to_vect

      #+begin_src python
      @prim('sexp->vect')
      def sexp_to_vect(sexp):
          if string_p(sexp):
              return sexp
          sexp_vect = list_to_vect(sexp)
          result_vect = []
          for s in sexp_vect:
              result_vect.append(sexp_to_vect(s))
          return result_vect
      #+end_src

*** *stack*

***** stack

      #+begin_src python
      Stack = Vect
      prim('Stack')(Stack)
      #+end_src

***** stack_p

      #+begin_src python
      @prim('stack?')
      def stack_p(x):
          return type(x) == Stack
      #+end_src

***** stack_pop

      #+begin_src python
      @prim('stack-pop')
      def stack_pop(stack):
          return stack.pop()
      #+end_src

***** stack_push

      #+begin_src python
      @prim('stack-push')
      def stack_push(value, stack):
          stack.append(value)
          return stack
      #+end_src

***** stack_drop

      #+begin_src python
      @prim('stack-drop')
      def stack_drop(stack):
          stack.pop()
          return stack
      #+end_src

***** stack_dup

      #+begin_src python
      @prim('stack-dup')
      def stack_dup(stack):
          a = stack.pop()
          stack.append(a)
          return stack
      #+end_src

***** stack_over

      #+begin_src python
      @prim('stack-over')
      def stack_over(stack):
          a = stack.pop()
          b = stack.pop()
          stack.append(b)
          stack.append(a)
          stack.append(b)
          return stack
      #+end_src

***** stack_tuck

      #+begin_src python
      @prim('stack-tuck')
      def stack_tuck(stack):
          a = stack.pop()
          b = stack.pop()
          stack.append(a)
          stack.append(b)
          stack.append(a)
          return stack
      #+end_src

***** stack_swap

      #+begin_src python
      @prim('stack-swap')
      def stack_swap(stack):
          a = stack.pop()
          b = stack.pop()
          stack.append(a)
          stack.append(b)
          return stack
      #+end_src

***** stack_length

      #+begin_src python
      @prim('stack-length')
      def stack_length(stack):
          return len(stack)
      #+end_src

***** stack_empty_p

      #+begin_src python
      @prim('stack-empty?')
      def stack_empty_p(stack):
          return len(stack) == 0
      #+end_src

*** *list*

***** Null & Cons

      #+begin_src python
      prim('<null>')(Null)
      prim('<cons>')(Cons)
      #+end_src

***** list_p

      #+begin_src python
      @prim('list?')
      def list_p(x):
          return null_p(x) or cons_p(x)
      #+end_src

***** vect_to_list

      #+begin_src python
      @prim('vect->list')
      def vect_to_list(vect):
          if vect == []:
              return null
          else:
              return cons(vect[0], vect_to_list(vect[1:]))
      #+end_src

***** list_to_vect

      #+begin_src python
      @prim('list->vect')
      def list_to_vect(l):
          vect = []
          while not null_p(l):
              vect.append(car(l))
              l = cdr(l)
          return vect
      #+end_src

***** list_length

      #+begin_src python
      def list_length(l):
          if null_p(l):
              return 0
          else:
              return list_length(cdr(l)) + 1
      #+end_src

***** list_ref

      #+begin_src python
      def list_ref(l, i):
          if null_p(l):
              print("- list_ref fail")
              print("  index greater then length of list")
              error()
          elif i == 0:
              return car(l)
          else:
              return list_ref(cdr(l), i-1)
      #+end_src

***** list_append

      #+begin_src python
      def list_append(ante, succ):
          if null_p(ante):
              return succ
          else:
              return cons(car(ante),
                          list_append(cdr (ante), succ))
      #+end_src

***** tail_cons

      #+begin_src python
      def tail_cons(ante, value):
          return list_append(ante, cons(value, null))
      #+end_src

***** list_zip_dict

      #+begin_src python
      @prim('list-zip-dict')
      def list_zip_dict(l1, l2):
          v1 = list_to_vect(l1)
          v2 = list_to_vect(l2)
          return vect_zip_dict(v1, v2)
      #+end_src

*** *dict*

***** Dict

      #+begin_src python
      Dict = dict
      prim('Dict')(Dict)
      #+end_src

***** dict_p

      #+begin_src python
      @prim('dict?')
      def dict_p(x):
          return type(x) == Dict
      #+end_src

***** dict_copy

      #+begin_src python
      @prim('dict-copy')
      def dict_copy(d):
          return d.copy()
      #+end_src

***** even_vect_to_dict

      #+begin_src python
      @prim('even-vect->dict')
      def even_vect_to_dict(vect):
          length = len(vect)
          if length % 2 != 0:
              print("- vect->dict fail")
              print("  length of vect must be even")
              print("  length : {}".format(length))
              print("  vect : {}".format(vect))
              error()

          d = {}
          i = 0
          while i < length:
              k = vect[i]
              v = vect[i+1]
              d[k] = v
              i = i + 2

          return d
      #+end_src

***** dict_to_assco_vect

      #+begin_src python
      @prim('dict->assco-vect')
      def dict_to_assco_vect(d):
          assco_vect = []
          for k, v in d.items():
              assco_vect.append((k, v))
          return assco_vect
      #+end_src

***** dict_to_assco_list

      #+begin_src python
      @prim('dict->assco-list')
      def dict_to_assco_list(d):
          assco_vect = dict_to_assco_vect(d)
          assco_list = vect_to_list(assco_vect)
          return assco_list
      #+end_src

***** dict_length

      #+begin_src python
      @prim('dict-length')
      def dict_length(d):
          return len(d)
      #+end_src

***** dict_empty_p

      #+begin_src python
      @prim('dict-empty?')
      def dict_empty_p(d):
          return len(d) == 0
      #+end_src

***** dict_find

      #+begin_src python
      @prim('dict-find')
      def dict_find(d, k):
          try:
              return VALUES(d[k], True)
          except KeyError:
              return False
      #+end_src

***** dict_get

      #+begin_src python
      @prim('dict-get')
      def dict_get(d, k):
          return d[k]
      #+end_src

***** dict_set

      #+begin_src python
      @prim('dict-set')
      def dict_set(d, k, v):
          d[k] = v
      #+end_src
***** dict_update -- no-side-effect

      #+begin_src python
      @prim('dict-update')
      def dict_update(d1, d2):
          d1 = dict_copy(d1)
          return d1.update(d2)
      #+end_src

***** dict_delete -- no-side-effect

      #+begin_src python
      @prim('dict-delete')
      def dict_delete(d, k):
          d = dict_copy(d)
          del d[k]
          return d
      #+end_src

*** *tuple*

***** Tuple

      #+begin_src python
      Tuple = tuple
      prim('Tuple')(Tuple)
      #+end_src

***** tuple_p

      #+begin_src python
      @prim('tuple?')
      def tuple_p(x):
          return type(x) == tuple
      #+end_src

***** vect_to_tuple

      #+begin_src python
      @prim('vect->tuple')
      def vect_to_tuple(vect):
          return tuple(vect)
      #+end_src

***** tuple_to_vect

      #+begin_src python
      @prim('tuple->vect')
      def tuple_to_vect(tu):
          return Vect(tu)
      #+end_src

***** tuple_length

      #+begin_src python
      @prim('tuple-length')
      def tuple_length(tu):
          return len(tu)
      #+end_src

***** tuple_empty_p

      #+begin_src python
      @prim('tuple-empty?')
      def tuple_empty_p(tu):
          return len(tu) == 0
      #+end_src
***** tuple_ref

      #+begin_src python
      @prim('tuple-ref')
      def tuple_ref(tu, index):
          return tu[index]
      #+end_src

***** tuple_append

      #+begin_src python
      @prim('tuple-append')
      def tuple_append(tu1, tu2):
          vect1 = Vect(tu1)
          vect1.extend(tu2)
          return tuple(vect1)
      #+end_src

*** *set*

***** Set

      #+begin_src python
      Set = set
      prim('Set')(Set)
      #+end_src

***** set_p

      #+begin_src python
      @prim('set?')
      def set_p(x):
          return type(x) == set
      #+end_src

***** vect_to_set

      #+begin_src python
      @prim('vect->set')
      def vect_to_set(vect):
          return set(vect)
      #+end_src

***** set_to_vect

      #+begin_src python
      @prim('set->vect')
      def set_to_vect(s):
          return Vect(s)
      #+end_src

***** set_length

      #+begin_src python
      @prim('set-length')
      def set_length(s):
          return len(s)
      #+end_src

***** set_empty_p

      #+begin_src python
      @prim('set-empty?')
      def set_empty_p(s):
          return len(s) == 0
      #+end_src

***** set_member_p

      #+begin_src python
      @prim('set-member?')
      def set_member_p(x, s):
          return x in s
      #+end_src

***** high school

      #+begin_src python
      @prim('set-disjoint?')
      def set_disjoint_p(s1, s2):
          return s1.isdisjoint(s2)

      @prim('set-subset?')
      def set_subset_p(s1, s2):
          return s1.issubset(s2)

      @prim('set-superset?')
      def set_superset_p(s1, s2):
          return s1.issuperset(s2)

      @prim('set-union')
      def set_union(s1, s2):
          return s1.union(s2)

      @prim('set-intersection')
      def set_intersection(s1, s2):
          return s1.intersection(s2)

      @prim('set-difference')
      def set_difference(s1, s2):
          return s1.difference(s2)

      @prim('set-symmetric-difference')
      def set_symmetric_difference(s1, s2):
          return s1.symmetric_difference(s2)
      #+end_src

*** *io*

***** py_print

      #+begin_src python
      @prim('py-print')
      def py_print(x):
          p_print(x)
      #+end_src

***** default_print

      #+begin_src python
      @prim('default-print')
      def default_print(x):
          if x == Bool:
              py_print("Bool")
          elif x == Int:
              py_print("Int")
          elif x == String:
              py_print("String")
          elif x == Vect:
              py_print("Vect")
          elif x == Dict:
              py_print("Dict")
          elif x == Tuple:
              py_print("Tuple")
          elif x == Set:
              py_print("Set")
          else:
              py_print(x)
          sys.stdout.flush()
      #+end_src

***** py_repr

      #+begin_src python
      @prim('py-repr')
      def py_repr(x):
          return repr(x)
      #+end_src

***** default_repr

      #+begin_src python
      @prim('default-repr')
      def default_repr(x):
          if x == Bool:
              return "Bool"
          elif x == Int:
              return "Int"
          elif x == String:
              return "String"
          elif x == Vect:
              return "Vect"
          elif x == Dict:
              return "Dict"
          elif x == Tuple:
              return "Tuple"
          elif x == Set:
              return "Set"
          else:
              return py_repr(x)
      #+end_src

***** nl -- newline

      #+begin_src python
      @prim('newline')
      def newline():
          print("")
          sys.stdout.flush()

      prim('nl')(newline)
      #+end_src

***** space

      #+begin_src python
      @prim('space')
      def space():
          p_print(" ")
      #+end_src

*** *bytes*

***** string_to_bytes -- encode

      #+begin_src python
      @prim('string->bytes')
      def string_to_bytes(string, encoding):
          return string.encode(encoding)
      #+end_src

***** bytes_to_string -- decode

      #+begin_src python
      @prim('bytes->string')
      def bytes_to_string(bs, encoding):
          return bs.decode(encoding)
      #+end_src

*** >< *file*

*** >< *socket*

***** import

      #+begin_src python
      import socket
      #+end_src

***** socket

      #+begin_src python
      @prim('socket')
      def p_socket():
          return socket.socket()
      #+end_src

***** gethostname

      #+begin_src python
      @prim('gethostname')
      def gethostname():
          return socket.gethostname()
      #+end_src

***** socket_connect

      #+begin_src python
      @prim('socket-connect')
      def socket_connect(sock, address):
          sock.connect(address)
      #+end_src

***** socket_bind

      #+begin_src python
      @prim('socket-bind')
      def socket_bind(sock, address):
          sock.bind(address)
      #+end_src

***** socket_listen

      #+begin_src python
      @prim('socket-listen')
      def socket_listen(sock):
          sock.listen(64)
      #+end_src

***** socket_accpet

      #+begin_src python
      @prim('socket-accept')
      def socket_accept(sock):
          clientsocket, address = sock.accept()
          return VALUES(clientsocket, address)
      #+end_src

***** socket_recv

      #+begin_src python
      @prim('socket-recv')
      def socket_recv(sock, length):
          message_bytes = sock.recv(length)
          return message_bytes
      #+end_src

***** socket_send

      #+begin_src python
      @prim('socket-send')
      def socket_send(sock, message_bytes):
          return_code = sock.send(message_bytes)
          return return_code
      #+end_src

*** *sys*

***** bye

      #+begin_src python
      @prim('bye')
      def bye():
          print("bye bye ^-^/")
          sys.exit()
      #+end_src

*** *repl*

***** read_sexp

******* read_char

        #+begin_src python
        def read_char(char_stack):
            if len(char_stack) == 0:
                return sys.stdin.read(1)
            else:
                return char_stack.pop()
        #+end_src

******* read_string

        - ';' as line comment

        #+begin_src python
        def read_string(char_stack):
            char_vect = []
            collecting_bytes_p = False

            while True:
                char = read_char(char_stack)
                if char == ';':
                    read_drop_comment(char_stack)

                elif not collecting_bytes_p:
                    if space_p(char):
                        pass
                    elif doublequote_p(char):
                        return read_doublequoted_string(char_stack)
                    elif delimiter_p(char):
                        char_vect.append(char)
                        break
                    else:
                        char_vect.append(char)
                        collecting_bytes_p = True

                else:
                    if (doublequote_p(char) or
                        delimiter_p(char) or
                        space_p(char)):
                        char_stack.append(char)
                        break
                    else:
                        char_vect.append(char)

            return "".join(char_vect)
        #+end_src

******* read_drop_comment

        #+begin_src python
        def read_drop_comment(char_stack):
            while True:
                char = read_char(char_stack)
                if char == '\n':
                    return
        #+end_src

******* read_doublequoted_string

        #+begin_src python
        def read_doublequoted_string(char_stack):
            char_vect = []
            while True:
                char = read_char(char_stack)
                if char == '"':
                    break
                else:
                    char_vect.append(char)
            return "".join(['"'] + char_vect + ['"'])
        #+end_src

******* read_sexp

        - with a char_stack,
          read a sexp from stdin.

        #+begin_src python
        def read_sexp(char_stack):
            string = read_string(char_stack)
            if string == '(':
                sexp_list = read_sexp_list_until_ket(char_stack, ')')
                return sexp_list
            elif string == '[':
                sexp_list = read_sexp_list_until_ket(char_stack, ']')
                return cons('begin', sexp_list)
            elif string == '{':
                sexp_list = read_sexp_list_until_ket(char_stack, '}')
                return cons('clo', sexp_list)
            elif string == '"':
                return read_doublequoted_string(char_stack)
            elif string == "'":
                sexp = read_sexp(char_stack)
                return cons('quote', cons(sexp, null))
            elif string == "`":
                sexp = read_sexp(char_stack)
                return cons('partquote', cons(sexp, null))
            else:
                return string
        #+end_src

******* read_sexp_list_until_ket

        #+begin_src python
        def read_sexp_list_until_ket(char_stack, ket):
            string = read_string(char_stack)
            if string == ket:
                return null
            else:
                char_vect = Vect(string)
                char_vect.reverse()
                char_stack.extend(char_vect)
                sexp = read_sexp(char_stack)
                recur = read_sexp_list_until_ket(char_stack, ket)
                return cons(sexp, recur)
        #+end_src

***** write_module_data_stack

      #+begin_src python
      def write_module_data_stack(module):
          newline()
          ds = module.vm.ds
          p_print(";{}> ".format(len(ds)))
          for data in ds:
              jo = getattr(module, 'w')
              jojo = JOJO([jo])
              rp = RP(jojo)
              vm = VM([data], [rp])
              vm.exe()
              space()
          newline()
      #+end_src

***** print_module_return_stack

******* print_module_return_stack

        #+begin_src python
        def print_module_return_stack(module):
            rs = module.vm.rs
            print("- return-stack * {} *".format(len(rs)))
            for rp in rs:
                return_point_print(rp)
        #+end_src

******* return_point_print

        #+begin_src python
        def return_point_print(rp):
            p_print("  - progress : {} / {}".format(rp.cursor, rp.length))
            newline()

            next_cursor = rp.cursor
            last_cursor = rp.cursor - 1

            if last_cursor == 0:
                pass
            else:
                p_print("    pass : ")
                i = 0
                while i < last_cursor:
                    jo_print(rp.body[i])
                    space()
                    i = i + 1
                newline()

            p_print("    last : ")
            jo_print(rp.body[last_cursor])
            newline()

            if next_cursor == rp.length:
                pass
            else:
                p_print("    next : ")
                i = next_cursor
                while i < rp.length:
                    jo_print(rp.body[i])
                    space()
                    i = i + 1
                newline()

            if len(rp.lr) == 0:
               pass
            else:
               p_print("    where : {}".format(rp.lr))
               newline()
        #+end_src

******* jo_print

        #+begin_src python
        def jo_print(jo):
            if fun_p(jo):
                p_print(jo.__module__)
                p_print(".")
                p_print(jo.__name__)
            else:
                p_print(jo)
        #+end_src

***** module_repl

******* [note]

        - a repl_char_stack is added to the module,
          for reading sexp one by one.

******* module_repl

        #+begin_src python
        def module_repl(module):
            module.repl_char_stack = []
            write_module_data_stack(module)
            try:
                while True:
                    module_repl_one_step(module)
            except KeyboardInterrupt:
                return
            except EXIT_MODULE_REPL:
                return
        #+end_src

******* EXIT_MODULE_REPL

        #+begin_src python
        class EXIT_MODULE_REPL(Exception):
            pass
        #+end_src

******* module_repl_one_step

        #+begin_src python
        def module_repl_one_step(module):
            sexp = read_sexp(module.repl_char_stack)
            if sexp == 'exit':
                raise EXIT_MODULE_REPL()

            try:
                merge_sexp_vect(module, [sexp])
                write_module_data_stack(module)
            except SystemExit:
                sys.exit()
            except:
                error_type = sys.exc_info()[0]
                error_name = error_type.__name__
                error_info = sys.exc_info()[1]
                print("- error : {}".format(error_name))
                print("  info : {}".format(error_info))
                print("  traceback : ")
                traceback.print_exc()
                call_module_debug(module, 1)
        #+end_src

*** *error*

***** error

      #+begin_src python
      prim('error')(error)
      #+end_src

***** module_debug

******* module_debug

        #+begin_src python
        @prim('module-debug')
        def module_debug(module, level):
            print("- enter debug-repl [level : {}]".format(level))
            module.debug_repl_char_stack = []
            print_module_return_stack(module)
            write_module_data_stack(module)
            try:
                while True:
                    module_debug_one_step(module, level)
            except KeyboardInterrupt:
                module.vm.rs = []
                newline()
                print("- leave debug-repl [level : {}]".format(level))
                print("  return-stack is cleared")
                print("  for module : {}".format(module.__name__))
                write_module_data_stack(module)
                return
            except EXIT_MODULE_DEBUG_REPL:
                module.vm.ds = []
                module.vm.rs = []
                print("- exit debug-repl [level : {}]".format(level))
                print("  return-stack is cleared")
                print("  data-stack is cleared")
                print("  for module : {}".format(module.__name__))
                write_module_data_stack(module)
                return
            except LEAVE_MODULE_DEBUG_REPL:
                module.vm.rs = []
                print("- leave debug-repl [level : {}]".format(level))
                print("  return-stack is cleared")
                print("  for module : {}".format(module.__name__))
                write_module_data_stack(module)
                return
        #+end_src

******* EXIT_MODULE_DEBUG_REPL

        #+begin_src python
        class EXIT_MODULE_DEBUG_REPL(Exception):
            pass
        #+end_src

******* LEAVE_MODULE_DEBUG_REPL

        #+begin_src python
        class LEAVE_MODULE_DEBUG_REPL(Exception):
            pass
        #+end_src

******* module_debug_one_step

        #+begin_src python
        def module_debug_one_step(module, level):
            p_print("debug[{}]> ".format(level))
            sys.stdout.flush()
            sexp = read_sexp(module.debug_repl_char_stack)
            if sexp == 'exit':
                raise EXIT_MODULE_DEBUG_REPL()
            if sexp == 'leave':
                raise LEAVE_MODULE_DEBUG_REPL()

            try:
                merge_sexp_vect(module, [sexp])
                write_module_data_stack(module)
            except SystemExit:
                sys.exit()
            except:
                error_type = sys.exc_info()[0]
                error_name = error_type.__name__
                error_info = sys.exc_info()[1]
                print("- error : {}".format(error_name))
                print("  info : {}".format(error_info))
                p_print("  traceback : ")
                traceback.print_exc()
                call_module_debug(module, level + 1)
        #+end_src

***** call_module_debug

      #+begin_src python
      def call_module_debug(module, level):
          jojo = JOJO([module, level, module_debug, nop])
          module.vm.rs.append(RP(jojo))
          module.vm.exe()
      #+end_src

*** *object*

***** Object

      #+begin_src python
      prim('Object')(object)
      #+end_src

*** *class*

***** value_to_class

      #+begin_src python
      @prim('value->class')
      def value_to_class(value):
          return type(value)
      #+end_src

***** subclass_p

      - treat UNION specially

      #+begin_src python
      @prim('subclass?')
      def subclass_p(c1, c2):
          if type(c2) == UNION:
             return c1 in c2.get_type_vect()
          else:
             return issubclass(c1, c2)
      #+end_src

*** *actor*

    #+begin_src python
    prim('schedule-start')(schedule_start)
    #+end_src

*** *misc*

***** nop

      #+begin_src python
      @prim('nop')
      def nop():
          return
      #+end_src

***** none

      #+begin_src python
      @prim('none')
      def none():
          return VALUES(None)
      #+end_src

***** doublequote

      #+begin_src python
      @prim('doublequote')
      def doublequote():
          return '"'
      #+end_src

***** sleep

      #+begin_src python
      @prim('sleep')
      def sleep(secs):
          time.sleep(secs)
          return
      #+end_src

***** fun_to_positional_default_arg_dict

      #+begin_src python
      def fun_to_positional_default_arg_dict(fun):
          signature = get_signature(fun)
          if signature == None:
              print("- fun_to_positional_default_arg_dict")
              print("  fail to get signature")
              print("  fun : {}".format(fun))
              error()
          parameters = signature.parameters
          return get_positional_default_arg_dict(parameters)
      #+end_src

***** prepare_data_arguments

      #+begin_src python
      @prim('prepare-data-arguments')
      def prepare_data_arguments(field_vect, value_vect, data):
          if not class_p(data):
              print("- prepare_data_arguments fail")
              print("  data must be a python class")
              print("  data : {}".format(data))
              error()

          if len(field_vect) == 0:
              normal_value_vect = value_vect
              field_value_vect = []
          elif len(field_vect) <= len(value_vect):
              normal_value_vect = value_vect[:-len(field_vect)]
              field_value_vect = value_vect[len(value_vect)-len(field_vect):]
          else:
              print("- prepare_data_arguments fail")
              print("  length of field_vect")
              print("    must be shorter then length of value_vect")
              print("  length of field_vect : {}".format(len(field_vect)))
              print("  length of value_vect : {}".format(len(value_vect)))
              print("  data : {}".format(data))
              print("  field_vect : {}".format(field_vect))
              error()

          field_dict = dict(zip(field_vect, field_value_vect))
          ordered_vect = []
          for field_name in data.field_name_vect:
              if field_name in field_dict.keys():
                  ordered_vect.append(field_dict[field_name])

          result_vect = normal_value_vect + ordered_vect
          return VALUES(*result_vect)
      #+end_src

***** keyword_apply

      #+begin_src python
      @prim('keyword-apply')
      def keyword_apply(field_vect, value_vect, fun):
          kwargs = dict(zip(field_vect, value_vect))
          return fun(**kwargs)
      #+end_src

* keyword_dict

*** [note] type

    - keyword : (-> module, body -- jo vect)

*** keyword_dict

    #+begin_src python
    keyword_dict = {}
    #+end_src

*** @keyword

    #+begin_src python
    def keyword(name):
        def decorator(fun):
            keyword_dict[name] = fun
            return fun
        return decorator
    #+end_src

*** (note)

    #+begin_src python
    @keyword("note")
    def k_note(module, body):
        return []
    #+end_src

*** (begin)

    #+begin_src python
    @keyword('begin')
    def k_begin(module, body):
        return sexp_list_emit(module, body)
    #+end_src

*** (clo)

    #+begin_src python
    @keyword('clo')
    def k_clo(module, body):
        return [CLO(sexp_list_emit(module, body))]
    #+end_src

*** (quote)

    #+begin_src python
    @keyword('quote')
    def k_quote(module, body):
        jo_vect = list_to_vect(body)
        return jo_vect
    #+end_src

*** (partquote)

    #+begin_src python
    @keyword('partquote')
    def k_partquote(module, sexp_list):
        jo_vect = []
        while not null_p(sexp_list):
            sexp = car(sexp_list)
            jo_vect.extend(k_partquote_one(module, sexp))
            sexp_list = cdr(sexp_list)
        return jo_vect

    def k_partquote_one(module, sexp):
        if cons_p(sexp):
            if car(sexp) == '@':
                return sexp_list_emit(module, cdr(sexp))
            else:
                jo_vect = []
                jo_vect.extend([MARK])
                jo_vect.extend(k_partquote(module, sexp))
                jo_vect.extend([COLLECT_LIST])
                return jo_vect
        else:
            return [sexp]
    #+end_src

*** (->)

    #+begin_src python
    @keyword('->')
    def k_arrow(module, sexp_list):
        jo_vect = []
        while not null_p(sexp_list):
            sexp = car(sexp_list)
            if not string_p(sexp):
                pass
            elif sexp == '--':
                break
            elif local_string_p(sexp):
                jo_vect.append(SET(sexp))
            else:
                pass
            sexp_list = cdr(sexp_list)
        jo_vect.reverse()
        return jo_vect
    #+end_src

*** (list)

    #+begin_src python
    @keyword('list')
    def k_list(module, sexp_list):
        jo_vect = []
        jo_vect.extend([MARK])
        jo_vect.extend(sexp_list_emit(module, sexp_list))
        jo_vect.extend([COLLECT_LIST])
        return jo_vect
    #+end_src

*** (vect)

    #+begin_src python
    @keyword('vect')
    def k_vect(module, sexp_list):
        jo_vect = []
        jo_vect.extend([MARK])
        jo_vect.extend(sexp_list_emit(module, sexp_list))
        jo_vect.extend([COLLECT_VECT])
        return jo_vect
    #+end_src

*** (stack)

    #+begin_src python
    @keyword('stack')
    def k_stack(module, sexp_list):
        return k_vect(module, sexp_list)
    #+end_src

*** (dict)

    #+begin_src python
    @keyword('dict')
    def k_dict(module, sexp_list):
        jo_vect = []
        jo_vect.extend([MARK])
        jo_vect.extend(sexp_list_emit(module, sexp_list))
        jo_vect.extend([COLLECT_VECT, even_vect_to_dict])
        return jo_vect
    #+end_src

*** (tuple)

    #+begin_src python
    @keyword('tuple')
    def k_tuple(module, sexp_list):
        jo_vect = []
        jo_vect.extend([MARK])
        jo_vect.extend(sexp_list_emit(module, sexp_list))
        jo_vect.extend([COLLECT_VECT, vect_to_tuple])
        return jo_vect

    keyword('*')(k_tuple)
    #+end_src

*** (set)

    #+begin_src python
    @keyword('set')
    def k_set(module, sexp_list):
        jo_vect = []
        jo_vect.extend([MARK])
        jo_vect.extend(sexp_list_emit(module, sexp_list))
        jo_vect.extend([COLLECT_VECT, vect_to_set])
        return jo_vect
    #+end_src

*** (primitive)

    #+begin_src python
    @keyword('primitive')
    def k_primitive(module, sexp_list):
        jo_vect = []
        sexp_vect = list_to_vect(sexp_list)
        for sexp in sexp_vect:
            if not string_p(sexp):
                print("- (primitive) syntax error")
                print("  body of (primitive) must be names")
                print("  non string sexp : {}".format(sexp))
                print("  body : {}".format(sexp_vect))
                error()
            else:
                jo_vect.extend([PRIMITIVE(operator.attrgetter(sexp)(module))])
        return jo_vect
    #+end_src

* top_level_keyword

*** (import)

***** k_import

      #+begin_src python
      @keyword("import")
      def k_import(module, body):
          name_vect = list_to_vect(body)

          if 'as' in name_vect:
              k_import_as(module, body)
              return []

          if null_p(body):
              return []

          for name in name_vect:
              if '.' in name:
                  print("- (import) syntax error")
                  print("  module name can not contain '.'")
                  print("  module name : {}".format(name))
                  p_print("  import body : ")
                  sexp_list_print(body)
                  newline()
                  error()

          for name in name_vect:
              k_import_one(module, name)

          return []
      #+end_src

***** k_import_one

      #+begin_src python
      def k_import_one(module, name):
          imported_module = importlib.import_module(name)
          jojo_define(module, name, imported_module)
      #+end_src

***** k_import_as

      #+begin_src python
      def k_import_as(module, body):
          name_vect = list_to_vect(body)
          if (len(name_vect) != 3 or
              name_vect[0] == 'as' or
              name_vect[1] != 'as' or
              name_vect[2] == 'as'):
              print("- (import) syntax error")
              print("  syntax for (import as) should be :")
              print("  (import <module-name> as <name>)")
              p_print("  import body : ")
              sexp_list_print(body)
              newline()
              error()
          name = name_vect[0]
          as_name = name_vect[2]
          imported_module = importlib.import_module(name)
          jojo_define(module, as_name, imported_module)
      #+end_src

*** (from)

***** k_from

      #+begin_src python
      @keyword("from")
      def k_from(module, body):
          vect_body = list_to_vect(body)
          if 'as' in vect_body:
              k_from_as(module, body)
              return []

          k_from_syntax_check(body)
          module_name = car(body)
          name_vect = list_to_vect(cdr(cdr(body)))
          imported_module = importlib.import_module(module_name)
          for name in name_vect:
              jojo_define(module, name, getattr(imported_module, name))

          return []
      #+end_src

***** k_from_syntax_check

      #+begin_src python
      def k_from_syntax_check(body):
          vect_body = list_to_vect(body)
          if len(vect_body) > 2:
              pass
          if vect_body[1] == 'import':
              return
          print("- (from) syntax error")
          print("  syntax for (from import) should be :")
          print("  (from <module-name> import <name> ...)")
          p_print("  import body : ")
          sexp_list_print(body)
          newline()
          error()
      #+end_src

***** k_from_as

      #+begin_src python
      def k_from_as(module, body):
          k_from_as_syntax_check(body)
          vect_body = list_to_vect(body)
          module_name = vect_body[0]
          name = vect_body[2]
          as_name = vect_body[4]
          imported_module = importlib.import_module(module_name)
          jojo_define(module, as_name, getattr(imported_module, name))
      #+end_src

***** k_from_as_syntax_check

      #+begin_src python
      def k_from_as_syntax_check(body):
          vect_body = list_to_vect(body)
          if len(vect_body) == 5:
              pass
          if vect_body[1] == 'import':
              pass
          if vect_body[3] == 'as':
              return
          print("- (from) syntax error")
          print("  syntax for (from import as) should be :")
          print("  (from <module-name> import <name> as <name>)")
          p_print("  import body : ")
          sexp_list_print(body)
          newline()
          error()
      #+end_src

*** (+jojo)

    #+begin_src python
    @keyword("+jojo")
    def plus_jojo(module, body):
        if list_length(body) == 0:
            print("- (+jojo) syntax error")
            print("  body of (+jojo) can not be empty")
            error()

        jojo_name = car(body)
        jojo_define(module, jojo_name,
                    JOJO(sexp_list_emit(module, cdr(body))))

        return []
    #+end_src

*** (+data)

***** plus_data

      #+begin_src python
      @keyword("+data")
      def plus_data(module, body):
          data_name = car(body)
          if not data_name_string_p(data_name):
              print("- (+data) syntax error")
              print("  data_name must be of form <...>")
              print("  data_name : {}".format(data_name))
              error()

          field_name_vect = body_to_field_name_vect(cdr(body))
          data_class = create_data_class(data_name, field_name_vect)
          data_class.__module__ = module
          jojo_define(module, data_name, data_class)
          # generate more bindings
          constructor_name = data_name[1:-1]
          jojo_define(module, constructor_name, JOJO([data_class, NEW]))
          predicate_name = "".join([constructor_name, "?"])
          jojo_define(module, predicate_name, DATA_PRED(data_class))
          return []
      #+end_src

***** body_to_field_name_vect

      #+begin_src python
      def body_to_field_name_vect(body):
          body_vect = list_to_vect(body)
          field_name_vect = []
          for sexp in body_vect:
              if string_p(sexp):
                  if message_string_p(sexp):
                      sexp = sexp[1:]
                      field_name_vect.append(sexp)
              elif cons_p(sexp):
                  if car(sexp) == '.':
                      vect1 = body_to_field_name_vect(cdr(sexp))
                      field_name_vect.extend(vect1)
          return field_name_vect
      #+end_src

***** data_name_string_p

      #+begin_src python
      def data_name_string_p(string):
          if not string_p(string):
              return False
          if len(string) < 3: # example : '<n>'
              return False
          elif string[0] != '<':
              return False
          elif string[-1] != '>':
              return False
          elif string.count('<') != 1:
              return False
          elif string.count('>') != 1:
              return False
          elif string.count('.') != 0:
              return False
          elif string.count(':') != 0:
              return False
          else:
              return True
      #+end_src

***** create_data_init

      #+begin_src python
      def create_data_init(field_name_vect):
          '''
          just like
          def __init__(self, x1, x2):
              self.__dict__['field-name-1'] = x1
              self.__dict__['field-name-2'] = x2
          '''
          if len(field_name_vect) == 0:
              code = "def init(self):pass"
              exec(code, globals())
              return init
          else:
              length = len(field_name_vect)
              pieces = []
              pieces.append("def init(self")
              for field_name, index in zip(field_name_vect, range(length)):
                  pieces.append(",{}".format('x'+str(index)))
              pieces.append("):")
              for field_name, index in zip(field_name_vect, range(length)):
                  pieces.append("self.__dict__['{}']={};".format(field_name,
                                                     ('x'+str(index))))
              code = ''.join(pieces)
              exec(code, globals())
              return init
      #+end_src

***** create_data_class

      - a data in jojo is simply a python class.

      #+begin_src python
      def create_data_class(data_name, field_name_vect):
          rev = vect_copy(field_name_vect)
          rev.reverse()
          def update_ns(ns):
              ns.update({
                  '__init__': create_data_init(field_name_vect),
              })
          return types.new_class(
              data_name,
              kwds = None,
              exec_body = update_ns)
      #+end_src

*** (+union)

***** plus_union

      #+begin_src python
      @keyword("+union")
      def plus_union(module, body):
          name = car(body)
          rest = cdr(body)
          jo_vect = sexp_list_emit(module, rest)
          jojo = JOJO(jo_vect)
          jojo_define(module, name, UNION(jojo))
          return []
      #+end_src

***** UNION

      #+begin_src python
      class UNION:
          def __init__(self, jojo):
              self.jojo = jojo

          def get_type_vect(self):
              vm = VM([], [RP(self.jojo)])
              vm.exe()
              return vm.ds
      #+end_src

*** [note] gene and disp

    - a gene in a module maintains a dict
      form tuple of type to disp

    - suppose

      in module m1 we have (+gene g1 ...)

      in module m2 we (import m1) and
      (+disp m1.g1 ...) for data in m2

      this means the the global state g1 of module m1
      can be changed by module m2

    - in such a hopelessly dynamic language,
      this is the only place we make use of the dynamic type.

*** (+gene)

***** plus_gene

      #+begin_src python
      @keyword("+gene")
      def plus_gene(module, body):
          name = car(body)
          rest = cdr(body)
          arrow = car(rest)
          arity = arrow_get_arity(arrow)
          if arity == 0:
              print("- (+gene) syntax error")
              print("  arity of arrow is zero")
              print("  gene dispatches on types of arguments")
              print("  can not define gene over nothing")
              print("  name : {}".format(name))
              p_print("  arrow : ")
              sexp_print(arrow)
              newline()
              error()

          default_jojo = JOJO(sexp_list_emit(module, rest))
          jojo_define(module, name, GENE(arity, default_jojo))
          return []
      #+end_src

***** arrow_get_arity

      #+begin_src python
      def arrow_get_arity(arrow):
          arity = 0
          sexp_vect = list_to_vect(cdr(arrow))
          for sexp in sexp_vect:
              if local_string_p(sexp):
                  arity = arity + 1
              elif sexp == '--':
                  break
              else:
                  pass

          return arity
      #+end_src

*** (+disp)

***** plus_disp

      #+begin_src python
      @keyword("+disp")
      def plus_disp(module, body):
          name = car(body)
          rest = cdr(body)
          arrow = car(rest)
          type_tuple_vect = arrow_get_type_tuple_vect(module, arrow)

          if not hasattr(module, name):
              print("- (+disp) syntax error")
              print("  name is undefined")
              print("  name : {}".format(name))
              error()

          gene = getattr(module, name)
          if type(gene) != GENE:
              print("- (+disp) syntax error")
              print("  type of name must be a gene")
              print("  name : {}".format(name))
              print("  type of name : {}".format(type(name)))
              error()

          jojo = JOJO(sexp_list_emit(module, rest))
          for type_tuple in type_tuple_vect:
              if type_tuple in gene.disp_dict:
                  print("- (+disp) fail")
                  print("  type_tuple for gene is already defined")
                  print("  type_tuple : {}".format(type_tuple))
                  print("  gene name : {}".format(name))
                  p_print("  arrow : ")
                  sexp_print(arrow)
                  newline()
                  error()
              else:
                  gene.disp_dict[type_tuple] = jojo

          return []
      #+end_src

***** arrow_get_type_vect

      #+begin_src python
      def arrow_get_type_vect(module, arrow):
          sexp_vect = list_to_vect(cdr(arrow))
          new_sexp_vect = []
          for sexp in sexp_vect:
              if local_string_p(sexp):
                  pass
              elif sexp == '--':
                  break
              else:
                  new_sexp_vect.append(sexp)

          new_sexp_list = vect_to_list(new_sexp_vect)
          jo_vect = sexp_list_emit(module, new_sexp_list)
          jojo = JOJO(jo_vect)
          vm = VM([], [RP(jojo)])
          vm.exe()

          return vm.ds
      #+end_src

***** type_vect_to_type_vect_vect

      #+begin_src python
      def type_vect_to_type_vect_vect(type_vect):
          type_vect_vect = []
          for t in type_vect:
              if type(t) == UNION:
                  type_vect_vect.append(t.get_type_vect())
              else:
                  type_vect_vect.append([t])

          return type_vect_vect
      #+end_src

***** arrow_get_type_tuple_vect

      #+begin_src python
      def arrow_get_type_tuple_vect(module, arrow):
          type_vect = arrow_get_type_vect(module, arrow)
          type_vect_vect = type_vect_to_type_vect_vect(type_vect)
          return Vect(itertools.product(*type_vect_vect))
      #+end_src

*** (+def)

***** plus_def

      #+begin_src python
      @keyword("+def")
      def plus_def(module, body):
          name = car(body)
          rest = cdr(body)
          jojo = JOJO(sexp_list_emit(module, rest))
          vm = VM([], [RP(jojo)])
          vm.exe()
          data = vm.ds[0]
          jojo_define(module, name, data)
          return []
      #+end_src

* key_jo_dict

*** [note] type

    - keyword : (-> module -- jo vect)

*** key_jo_dict

    #+begin_src python
    key_jo_dict = {}
    #+end_src

*** key_jo

    #+begin_src python
    def key_jo(name, jo_vect):
        key_jo_dict[name] = jo_vect
    #+end_src

*** key_jo s

    #+begin_src python
    key_jo('apply', [APPLY])
    key_jo('ifte', [IFTE])
    key_jo('new', [NEW])
    key_jo(',', [])

    key_jo('mark', [MARK])
    key_jo('collect-vect', [COLLECT_VECT])
    key_jo('vect-spread', [VECT_SPREAD])
    key_jo('collect-list', [COLLECT_LIST])
    key_jo('list-spread', [LIST_SPREAD])

    key_jo('clear', [CLEAR])
    #+end_src

*** key_jo for actor

    #+begin_src python
    key_jo('receive', [RECEIVE])
    key_jo('send', [SEND])
    key_jo('spawn', [SPAWN])
    key_jo('action', [ACTION])
    #+end_src

* macro_dict

*** [note] type

    - macro : (-> body -- sexp)
      where body is sexp_list

*** macro_dict

    #+begin_src python
    macro_dict = {}
    #+end_src

*** @macro

    #+begin_src python
    def macro(name):
        def decorator(fun):
            macro_dict[name] = fun
            return fun
        return decorator
    #+end_src

*** (cond)

    #+begin_src python
    @macro('cond')
    def k_cond(body):
        def recur(rest):
            if list_length(rest) == 2:
                q = list_ref(rest, 0)
                a = list_ref(rest, 1)
                if q == 'else':
                    return a
                else:
                    return vect_to_sexp(
                        ['begin',
                         q, ['clo', a],
                         ['clo',
                          ['quote', body],
                          'report-cond-mismatch'],
                         'ifte'])
            else:
                q = list_ref(rest, 0)
                a = list_ref(rest, 1)
                return vect_to_sexp(
                    ['begin',
                     q, ['clo', a],
                     ['clo', recur(cdr(cdr(rest)))],
                     'ifte'])
        return recur(body)

    @prim('report-cond-mismatch')
    def report_cond_mismatch(body):
        print("- cond mismatch")
        p_print("  body : ")
        sexp_print(body)
        newline()
        error()
    #+end_src

*** (if)

    #+begin_src python
    @macro('if')
    def k_if(body):
        length = list_length(body)
        if length != 3:
            print("- (if) syntax fail")
            print("  body of (if) must has 3 sexps")
            print("  body length : {}".format(length))
            p_print("  body : ")
            sexp_list_print(body)
            newline()
            error()

        return vect_to_sexp(
            ['begin',
             car(body),
             ['clo', car(cdr(body))],
             ['clo', car(cdr(cdr(body)))],
             'ifte'])
    #+end_src

*** (when)

    #+begin_src python
    @macro('when')
    def k_when(body):
        length = list_length(body)
        if length <= 1:
            print("- (when) syntax fail")
            print("  length of body of (when) must be greater then 1")
            print("  body length : {}".format(length))
            p_print("  body : ")
            sexp_list_print(body)
            newline()
            error()

        rest_list = cdr(body)
        rest_vect = ['begin']
        rest_vect.extend(list_to_vect(rest_list))

        return vect_to_sexp(
            ['begin',
             car(body),
             ['clo', rest_vect],
             ['clo'],
             'ifte'])
    #+end_src

*** (call)

    - use 'prepare-default-arguments'
      to push default arguments to stack
      and call the function

    #+begin_src python
    @macro('call')
    def k_call(body):
        rest_vect = list_to_vect(cdr(body))
        name = car(body)
        fields = []
        new_body = ['begin']
        for sexp in rest_vect:
           if message_string_p(sexp):
               fields.append(sexp[1:])
           else:
               new_body.append(sexp)
        return vect_to_sexp(
            ['begin',
             ['quote', fields], 'list->vect',
             'mark', new_body, 'collect-vect',
             ['primitive', name],
             'keyword-apply'])
    #+end_src

*** (create)

    #+begin_src python
    @macro('create')
    def k_create(body):
        rest_vect = list_to_vect(cdr(body))
        name = car(body)
        fields = []
        new_body = ['begin']
        for sexp in rest_vect:
            if message_string_p(sexp):
                fields.append(sexp[1:])
            else:
                new_body.append(sexp)
        return vect_to_sexp(
            ['begin',
             ['quote', fields], 'list->vect',
             'mark', new_body, 'collect-vect',
             name,
             'prepare-data-arguments',
             name,
             'new'])
    #+end_src

*** (main-act)

    #+begin_src python
    @macro('main-act')
    def k_main_act(body):
        body_vect = list_to_vect(body)
        return vect_to_sexp(
            ['begin',
             'schedule-start',
             (['clo'] + body_vect),
             'action'])
    #+end_src

* epilog -- interface

*** maybe_drop_shebang

    #+begin_src python
    def maybe_drop_shebang(code):
        length = len(code)
        if length < 3:
            return code
        elif code[0:2] != '#!':
            return code
        else:
            end_of_first_line = code.find('\n')
            if end_of_first_line == -1:
                return ""
            else:
                return code[end_of_first_line:]
    #+end_src

*** load

    - path is used as module name

    #+begin_src python
    def load(name, path):
        current_module = sys.modules[inspect.stack()[1].frame.f_globals['__name__']]
        if ((current_module.__name__ == '__main__') or
            (not hasattr(current_module, '__file__')) or
            (path[0] == '/')):
            path = os.path.abspath(path)
        else:
            current_module_dir = os.path.dirname(current_module.__file__)
            path = "/".join([current_module_dir, path])

        if not os.path.exists(path):
            print("- load fail")
            print("  path does not exist")
            print("  path : {}".format(path))
            error()

        if not os.path.isfile(path):
            print("- load fail")
            print("  path is not file")
            print("  path : {}".format(path))
            error()

        with open(path, "r") as f:
            code = f.read()
            code = maybe_drop_shebang(code)
            sexp_vect = parse_sexp_vect(code_scan(code))
            module = compile_module(name, sexp_vect)

        module.__file__ = path

        return module
    #+end_src

*** core_module

***** load_core

      #+begin_src python
      def load_core(path):
          path = os.path.abspath(path)

          if not os.path.exists(path):
              print("- load_core fail")
              print("  path does not exist")
              print("  path : {}".format(path))
              error()

          if not os.path.isfile(path):
              print("- load_core fail")
              print("  path is not file")
              print("  path : {}".format(path))
              error()

          with open(path, "r") as f:
              code = f.read()
              sexp_vect = parse_sexp_vect(code_scan(code))
              module = compile_core_module(path, sexp_vect)

          module.__file__ = path

          return module
      #+end_src

***** core_module

      #+begin_src python
      current_module = sys.modules[__name__]
      current_module_dir = os.path.dirname(current_module.__file__)
      core_path = "/".join([current_module_dir, "core.jo"])
      core_module = load_core(core_path)
      #+end_src

*** repl

    #+begin_src python
    repl_counter = 0
    @prim('repl')
    def repl():
        global repl_counter
        module = new_module('jojo-repl-' + str(repl_counter))
        repl_counter = repl_counter + 1
        merge_prim_dict(module)
        merge_module(module, core_module)
        module_repl(module)
    #+end_src

*** import hook

    #+begin_src python
    class MetaLoader:
        def __init__(self, path):
            self.path = path

        def load_module(self, fullname):
            if fullname in sys.modules:
                return sys.modules[fullname]
            if not self.path:
                return
            return load(fullname, self.path)


    class MetaImporter:
        def find_on_path(self, fullname):
            fls = ["%s/__init__.jo", "%s.jo"]
            dirpath = "/".join(fullname.split("."))
            for pth in sys.path:
                pth = os.path.abspath(pth)
                for fp in fls:
                    composed_path = fp % ("%s/%s" % (pth, dirpath))
                    if os.path.exists(composed_path):
                        return composed_path

        def find_module(self, fullname, path=None):
            path = self.find_on_path(fullname)
            # print("- find_module")
            # print("  fullname : {}".format(fullname))
            # print("  path : {}".format(path))
            if path:
                return MetaLoader(path)

    sys.meta_path.insert(0, MetaImporter())

    if "" not in sys.path:
        sys.path.insert(0, "")
    #+end_src
