#+property: tangle jojo.py
#+title: jojo's programming adventure in python

* [todo-stack]

*** tuple

    - do not view tuple result as multiple-return-value
      only jojo can use multiple-return-value

*** macro

    - (partquote)
    - (@)

    - (->)

    - (list)
    - (dict)
    - (vect)
    - (tuple)
    - (set)

    - (conditional) in jojo as macro [as a macro system test]

    - (+data)
    - (+class)
    - (+message)

    - 'equal?' as message
    - 'write' as message

    - (case)

*** interface

***** module

      - import as python

      - code in jojo can be module
        - setuptools
          to use dynamiclly generated module

***** command line

*** prim

    - cover python's builtin and standard libraries

*** docs

***** vm

      - specify the design of jo in jojo vm

      - specify which semantic subset of python is captured by jojo vm

* prolog

*** import

    #+begin_src python
    import inspect
    import types
    import importlib
    import sys
    import os
    #+end_src

*** utility

***** get_signature

      #+begin_src python
      def get_signature(fun):
          try:
              return inspect.signature(fun)
          except ValueError:
              return False
      #+end_src

***** fun_p

      #+begin_src python
      def fun_p(x):
          if (isinstance(x, types.LambdaType) or
              isinstance(x, types.MethodType)):
              return True
          elif (isinstance(x, types.BuiltinFunctionType) or
                isinstance(x, types.BuiltinMethodType)):
              return get_signature(x)
          else:
              return False
      #+end_src

***** class_p

      #+begin_src python
      def class_p(x):
          if not inspect.isclass(x):
              return False
          elif x == type:
              return False
          else:
              return True
      #+end_src

***** Vect

      #+begin_src python
      Vect = list
      #+end_src

*** error handling

***** JOJO_ERROR

      #+begin_src python
      class JOJO_ERROR(Exception):
          pass
      #+end_src

* vm

*** VM

***** RP

      #+begin_src python
      class RP:
          def __init__(self, fun):
              self.cursor = 0
              self.length = fun.length
              self.body = fun.body
              self.lr = fun.lr.copy()
      #+end_src

***** VM

      #+begin_src python
      class VM:
          def __init__(self, ds, rs):
              self.ds = ds
              self.rs = rs

          def exe(self):
              return exe(self)
      #+end_src

***** push_result_to_vm

      #+begin_src python
      def push_result_to_vm(result, vm):
          if type(result) == tuple:
              vm.ds.extend(result)
          elif result == None:
              pass
          else:
              vm.ds.append(result)
      #+end_src

*** jo

***** GET -- get local variable

      #+begin_src python
      class GET:
          def __init__(self, name):
              self.name = name

          def jo_exe(self, rp, vm):
              value = rp.lr[self.name]
              vm.ds.append(value)
      #+end_src

***** SET -- set local variable

      #+begin_src python
      class SET:
          def __init__(self, name):
              self.name = name

          def jo_exe(self, rp, vm):
              value = vm.ds.pop()
              rp.lr[self.name] = value
      #+end_src

***** JOJO -- top level

      #+begin_src python
      class JOJO:
          def __init__(self, body):
              self.length = len(body)
              self.body = Vect(body)
              self.lr = {}

          def jo_exe(self, rp, vm):
              vm.rs.append(RP(self))
      #+end_src

***** MACRO -- top level

      #+begin_src python
      class MACRO:
          def __init__(self, body):
              self.length = len(body)
              self.body = Vect(body)
              self.lr = {}

          def jo_exe(self, rp, vm):
              vm.rs.append(RP(self))
      #+end_src

***** CLO -- closure

      #+begin_src python
      class CLO:
          def __init__(self, body):
              self.body = body

          def jo_exe(self, rp, vm):
              new_jojo = JOJO(self.body)
              new_jojo.lr = rp.lr
              vm.ds.append(new_jojo)
      #+end_src

***** APPLY

      #+begin_src python
      class APPLY:
          @classmethod
          def jo_exe(cls, rp, vm):
              clo = vm.ds.pop()
              clo.jo_exe(rp, vm)
      #+end_src

***** IFTE -- branching

      #+begin_src python
      class IFTE:
          @classmethod
          def jo_exe(self, rp, vm):
              clo2 = vm.ds.pop()
              clo1 = vm.ds.pop()
              test = vm.ds.pop()
              if test:
                  vm.rs.append(RP(clo1))
              else:
                  vm.rs.append(RP(clo2))
      #+end_src

***** MSG -- message to object

      #+begin_src python
      class MSG:
          def __init__(self, message):
              self.message = message

          def jo_exe(self, rp, vm):
              o = vm.ds.pop()
              fun = getattr(o, self.message)
              exe_jo(fun, rp, vm)
      #+end_src

***** NEW -- create object from class

      #+begin_src python
      class NEW:
          @classmethod
          def jo_exe(self, rp, vm):
              c = vm.ds.pop()
              if not class_p(c):
                  print ("- NEW.jo_exe fail")
                  print ("  argument is not a class : {}".format(c))
                  raise JOJO_ERROR()
              exe_fun(c, vm)
      #+end_src

***** CALL -- call a name from a module

      #+begin_src python
      class CALL:
          def __init__(self, module, name):
              self.module = module
              self.name = name

          def jo_exe(self, rp, vm):
              jo = getattr(self.module, self.name)
              exe_jo(jo, rp, vm)
      #+end_src

*** exe

***** exe

      #+begin_src python
      def exe(vm):
          while vm.rs != []:
              exe_one_step(vm)
              print (vm.ds)
          print ("- exe end")
          return vm
      #+end_src

***** exe_one_step

      #+begin_src python
      def exe_one_step(vm):
          rp = vm.rs.pop()
          jo = rp.body[rp.cursor]

          # handle tail call
          if rp.cursor >= rp.length - 1:
             pass
          else:
             rp.cursor = rp.cursor + 1
             vm.rs.append(rp)

          # dispatching
          exe_jo(jo, rp, vm)
      #+end_src

***** exe_jo

      #+begin_src python
      def exe_jo(jo, rp, vm):
          if fun_p(jo):
              exe_fun(jo, vm)
          elif hasattr(jo, "jo_exe"):
              jo.jo_exe(rp, vm)
          else:
              vm.ds.append(jo)
      #+end_src

***** exe_fun

******* [note]

        - normal arguments are called positional arguments.

        - there are also keyword-only arguments,
          because after *args,
          the information about position will be lost.

        - before *args
          each positional arguments took one position
          do not respect default arguments

        - if *args is used in a function signature
          pass it as a vect

        - if **kwargs is used in a function signature
          pass it as a dict

******* exe_fun

        #+begin_src python
        def exe_fun(fun, vm):
            signature = get_signature(fun)

            if not signature:
                print ("- exe_fun fail to get signature")
                print ("  fun : {}".format(fun))
                raise JOJO_ERROR()

            parameters = signature.parameters

            if has_para_dict(parameters):
                arg_dict = get_default_arg_dict(parameters)
                top_of_ds = vm.ds.pop()
                if not isinstance(top_of_ds, dict):
                    print ("- exe_fun fail")
                    print ("  when fun require a arg_dict")
                    print ("  the top of data stack is not a dict")
                    print ("  fun : {}".format(fun))
                    print ("  top of data stack : {}".format(top_of_ds))
                    raise JOJO_ERROR()
                arg_dict.update(top_of_ds)
            else:
                arg_dict = None

            if has_para_vect(parameters):
                top_of_ds = vm.ds.pop()
                if not vect_p(top_of_ds):
                    print ("- exe_fun fail")
                    print ("  when fun require a arg_vect")
                    print ("  the top of data stack is not a vect")
                    print ("  fun : {}".format(fun))
                    print ("  top of data stack : {}".format(top_of_ds))
                    raise JOJO_ERROR()
                arg_vect = top_of_ds
            else:
                arg_vect = []

            positional_para_length = get_positional_para_length(parameters)
            args = []
            i = 0
            while i < positional_para_length:
                args.append(vm.ds.pop())
                i = i + 1
            args.reverse()
            args.extend(arg_vect)

            if arg_dict == None:
                result = fun(*args)
            else:
                result = fun(*args, **arg_dict)

            push_result_to_vm(result, vm)
        #+end_src

******* get_positional_para_length

        #+begin_src python
        def get_positional_para_length(parameters):
            n = 0
            for v in parameters.values():
                if (v.kind == inspect.Parameter.POSITIONAL_ONLY or
                    v.kind == inspect.Parameter.POSITIONAL_OR_KEYWORD):
                    n = n + 1
            return n
        #+end_src

******* has_para_vect

        #+begin_src python
        def has_para_vect(parameters):
            for v in parameters.values():
                if (v.kind == inspect.Parameter.VAR_POSITIONAL):
                    return True
            return False
        #+end_src

******* has_para_dict

        #+begin_src python
        def has_para_dict(parameters):
            for v in parameters.values():
                if (v.kind == inspect.Parameter.KEYWORD_ONLY or
                    v.kind == inspect.Parameter.VAR_KEYWORD):
                    return True
            return False
        #+end_src

******* get_default_arg_dict

        #+begin_src python
        def get_default_arg_dict(parameters):
            default_dict = {}
            for v in parameters.values():
                if (v.kind == inspect.Parameter.KEYWORD_ONLY and
                    v.default != inspect.Parameter.empty):
                    default_dict[v.name] = v.default
            return default_dict
        #+end_src

* scan -- sexp lexer

*** scan_string_vect

    #+begin_src python
    def scan_string_vect(string):
        string_vect = []
        i = 0
        length = len(string)
        while i < length:
            s = string[i]

            if space_p(s):
                i = i + 1

            elif delimiter_p(s):
                string_vect.append(s)
                i = i + 1

            elif doublequote_p(s):
                doublequote_end_index = string.find('"', i+1)
                if doublequote_end_index == -1:
                    print ("- scan_string_vect fail")
                    print ("  doublequote mismatch")
                    print ("  string : {}".format(string))
                    raise JOJO_ERROR()
                end = doublequote_end_index + 1
                string_vect.append(string[i:end])
                i = end

            else:
                end = find_end(string, i+1)
                string_vect.append(string[i:end])
                i = end

        return string_vect
    #+end_src

*** find_end

    #+begin_src python
    def find_end(string, begin):
        length = len(string)
        i = begin
        while True:
           if i == length:
               return i
           s = string[i]
           if space_p(s) or delimiter_p(s) or doublequote_p(s):
               return i
           i = i + 1
    #+end_src

*** space_p

    #+begin_src python
    def space_p(s):
        return s.isspace()
    #+end_src

*** delimiter_p

    #+begin_src python
    def delimiter_p(s):
        return (s == '(' or
                s == ')' or
                s == '[' or
                s == ']' or
                s == '{' or
                s == '}' or
                s == ',' or
                s == '`' or
                s == "'")
    #+end_src

*** doublequote_p

    #+begin_src python
    def doublequote_p(s):
        return s == '"'
    #+end_src

* null & cons

*** Null

    #+begin_src python
    class Null:
        pass
    #+end_src

*** null

    #+begin_src python
    null = Null()
    #+end_src

*** null_p

    #+begin_src python
    def null_p(x):
        return x == null
    #+end_src

*** Cons

    #+begin_src python
    class Cons:
        def __init__(self, car, cdr):
            self.car = car
            self.cdr = cdr
    #+end_src

*** cons

    #+begin_src python
    def cons(car, cdr):
        if list_p(cdr):
            return Cons(car, cdr)
        else:
            print ("- cons fail")
            print ("  cdr of cons must be a cons or null")
            print ("  cdr : {}".format(cdr))
            raise JOJO_ERROR()
    #+end_src

*** cons_p

    #+begin_src python
    def cons_p(x):
        return isinstance(x, Cons)
    #+end_src

*** list_p

    #+begin_src python
    def list_p(x):
        return null_p(x) or cons_p(x)
    #+end_src

*** cdr

    #+begin_src python
    def cdr(x):
        return x.cdr
    #+end_src

*** car

    #+begin_src python
    def car(x):
        return x.car
    #+end_src

* sexp -- string expression

*** parse_sexp_vect -- string vect to sexp vect

    - sexp := Null | Cons(sexp, sexp_list) | string

    - syntax sugar :
      - [...] -> (begin ...)
      - {...} -> (clo ...)
      - ' ... -> (quote ...)
      - ` ... -> (partquote ...)

    #+begin_src python
    def parse_sexp_vect(string_vect):
        length = len(string_vect)
        i = 0
        sexp_vect = []
        while i < length:
           s, i = parse_sexp(string_vect, i)
           sexp_vect.append(s)
        return sexp_vect
    #+end_src

*** parse_sexp

    #+begin_src python
    def parse_sexp(string_vect, i):
        string = string_vect[i]
        if string == '(':
            return parse_sexp_cons_until_ket(string_vect, i+1, ')')
        elif string == '[':
            s_cons, i1 = parse_sexp_cons_until_ket(string_vect, i+1, ']')
            return (cons('begin', s_cons), i1)
        elif string == '{':
            s_cons, i1 = parse_sexp_cons_until_ket(string_vect, i+1, '}')
            return (cons('clo', s_cons), i1)
        elif string == "'":
            s, i1 = parse_sexp(string_vect, i+1)
            return (cons('quote', cons(s, null)), i1)
        elif string == "`":
            s, i1 = parse_sexp(string_vect, i+1)
            return (cons('partquote', cons(s, null)), i1)
        else:
            return (string, i+1)
    #+end_src

*** parse_sexp_cons_until_ket

    #+begin_src python
    def parse_sexp_cons_until_ket(string_vect, i, ket):
        string = string_vect[i]
        if string == ket:
            return (null, i+1)
        else:
            s, i1 = parse_sexp(string_vect, i)
            s_cons, i2 = \
                parse_sexp_cons_until_ket(string_vect, i1, ket)
            return (cons(s, s_cons), i2)
    #+end_src

*** write

    #+begin_src python
    def write(x):
        print(x, end="")
    #+end_src

*** write_sexp

    #+begin_src python
    def write_sexp(s):
        if null_p(s):
            write ("null")
        elif cons_p(s):
            write ("(")
            write_sexp_cons(s)
            write (")")
        else:
            write (s)
    #+end_src

*** write_sexp_cons

    #+begin_src python
    def write_sexp_cons(s_cons):
        if null_p(s_cons):
            pass
        elif null_p(cdr(s_cons)):
            write_sexp(car(s_cons))
        else:
            write_sexp(car(s_cons))
            write (" ")
            write_sexp_cons(cdr(s_cons))
    #+end_src

* vect

*** vect_p

    #+begin_src python
    def vect_p(x):
        return type(x) == Vect
    #+end_src

*** vect_to_sexp

    #+begin_src python
    def vect_to_sexp(vect):
        if vect == []:
            return null
        elif not vect_p(vect):
            return vect
        else:
            return cons(vect_to_sexp(vect[0]),
                        vect_to_sexp(vect[1:]))
    #+end_src

* list

*** list_length

    #+begin_src python
    def list_length(l):
        if null_p(l):
            return 0
        else:
            return list_length(cdr(l)) + 1
    #+end_src

*** list_ref

    #+begin_src python
    def list_ref(l, i):
        if null_p(l):
            print ("- list_ref fail")
            print ("  index greater then length of list")
            raise JOJO_ERROR()
        elif i == 0:
            return car(l)
        else:
            return list_ref(cdr(l), i-1)
    #+end_src

*** list_append

    #+begin_src python
    def list_append(ante, succ):
        if null_p(ante):
            return succ
        else:
            return cons(car(ante),
                        list_append(cdr (ante), succ))
    #+end_src

*** tail_cons

    #+begin_src python
    def tail_cons(ante, value):
        return list_append(ante, cons(value, null))
    #+end_src

* compile_module

*** [note] syntax

    - top level :
      - (+jojo)
      - (+macro)
      - (+data) ><

    - in jojo :
      - (begin)
      - (clo)

      - (quote)
      - (partquote)
      - (@)

      - (if)
      - (cond)
      - (case) ><

    - key jo :
      - apply
      - ifte
      - new

    - jo pattern :
      - :local
      - :local!
      - .message

*** list_to_vect

    #+begin_src python
    def list_to_vect(l):
        stack = []
        while not null_p(l):
            stack.append(car(l))
            l = cdr(l)
        return stack
    #+end_src

*** get_jojo_name_vect

    #+begin_src python
    def get_jojo_name_vect(sexp_vect):
        jojo_name_vect = []
        for sexp in sexp_vect:
            if not cons_p(sexp):
                pass
            elif car(sexp) == '+jojo':
                body = cdr(sexp)
                jojo_name = car(body)
                jojo_name_vect.append(jojo_name)
        return jojo_name_vect
    #+end_src

*** get_macro_name_vect

    #+begin_src python
    def get_macro_name_vect(sexp_vect):
        macro_name_vect = []
        for sexp in sexp_vect:
            if not cons_p(sexp):
                pass
            elif car(sexp) == '+macro':
                body = cdr(sexp)
                macro_name = car(body)
                macro_name_vect.append(macro_name)
        return macro_name_vect
    #+end_src

*** compile_module

    #+begin_src python
    def compile_module(module_name, sexp_vect):
        module = types.ModuleType(module_name)
        setattr(module, 'jojo_name_vect',
                get_jojo_name_vect(sexp_vect))
        setattr(module, 'macro_name_vect',
                get_macro_name_vect(sexp_vect))
        setattr(module, 'imported_module_dict', {})
        for sexp in sexp_vect:
            if cons_p(sexp):
                top_level_keyword = car(sexp)
                fun = top_level_keyword_dict[top_level_keyword]
                fun(module, cdr(sexp))
        return module
    #+end_src

*** sexp_vect_emit

    #+begin_src python
    def sexp_vect_emit(module, sexp_vect):
        jo_vect = []
        while not null_p(sexp_vect):
            sexp = car(sexp_vect)
            jo_vect.extend(sexp_emit(module, sexp))
            sexp_vect = cdr(sexp_vect)
        return jo_vect
    #+end_src

*** sexp_emit

    #+begin_src python
    def sexp_emit(module, sexp):
        if null_p(sexp):
            return null_emit(module, sexp)
        elif cons_p(sexp):
            return cons_emit(module, sexp)
        else:
            return string_emit(module, sexp)
    #+end_src

*** null_emit

    #+begin_src python
    def null_emit(module, sexp):
        return [null]
    #+end_src

*** cons_emit

    #+begin_src python
    def cons_emit(module, cons):
        keyword = car(cons)

        if keyword in keyword_dict.keys():
            fun = keyword_dict[keyword]
            return fun(module, cdr(cons))

        if keyword in macro_dict.keys():
            fun = macro_dict[keyword]
            new_sexp = fun(cdr(cons))
            return sexp_emit(module, new_sexp)

        macro_name_vect = getattr(module, "macro_name_vect")
        if keyword in macro_name_vect:
            if not hasattr(module, keyword):
                print ("- cons_emit fail")
                print ("  must define a macro before using it")
                print ("  macro name : {}".format(keyword))
                raise JOJO_ERROR()
            else:
                macro = getattr(module, keyword)
                vm = vm([cdr(cons)],
                        [RP(macro)])
                vm = vm.exe()
                new_sexp = vm.ds[0]
                return sexp_emit(module, new_sexp)

        else:
            print("- cons_emit fail")
            print("  meet unknown keyword : {}".format(keyword))
            raise JOJO_ERROR()
    #+end_src

*** string_emit

***** string_emit

      #+begin_src python
      def string_emit(module, string):

          if int_string_p(string):
              return [int(string)]

          if doublequoted_string_p(string):
              string = string[1:len(string)-1]
              return [string]

          if local_string_p(string):
              return [GET(string)]
          if set_local_string_p(string):
              string = string[:len(string)-1]
              return [SET(string)]

          if message_string_p(string):
              string = string[1:len(string)]
              return [MSG(string)]

          if string == 'apply':
              return [APPLY]
          if string == 'ifte':
              return [IFTE]
          if string == 'new':
              return [NEW]
          if string == ',':
              return []

          jojo_name_vect = getattr(module, 'jojo_name_vect')
          if string in jojo_name_vect:
              return [CALL(module, string)]

          imported_module_dict = getattr(module, 'imported_module_dict')
          if string in imported_module_dict.keys():
              imported_module = imported_module_dict[string]
              return [imported_module]

          if string in prim_dict.keys():
              return [prim_dict[string]]

          print ("- string_emit fail")
          print ("  meet undefined string : {}".format(string))
          raise JOJO_ERROR()
      #+end_src

***** int_string_p

      #+begin_src python
      def int_string_p(string):
          length = len(string)
          if length == 0:
              return False
          elif string[0] == '-':
              return nat_string_p(string[1:length-1])
          else:
              return nat_string_p(string)
      #+end_src

***** nat_string_p

      #+begin_src python
      def nat_string_p(string):
          return string.isdecimal()
      #+end_src

***** doublequoted_string_p

      #+begin_src python
      def doublequoted_string_p(string):
          if len(string) <= 2:
              return False
          elif string[0] != '"':
              return False
          elif string[len(string)-1] != '"':
              return False
          else:
              return True
      #+end_src

***** local_string_p

      #+begin_src python
      def local_string_p(string):
          if len(string) <= 1:
              return False
          elif string[0] != ':':
              return False
          elif string[len(string)-1] == '!':
              return False
          else:
              return True
      #+end_src

***** set_local_string_p

      #+begin_src python
      def set_local_string_p(string):
          if len(string) <= 2:
              return False
          elif string[0] != ':':
              return False
          elif string[len(string)-1] != '!':
              return False
          else:
              return True
      #+end_src

***** message_string_p

      #+begin_src python
      def message_string_p(string):
          if len(string) <= 1:
              return False
          elif string[0] != '.':
              return False
          else:
              return True
      #+end_src

* prim_dict

*** prim_dict

    #+begin_src python
    prim_dict = {}
    #+end_src

*** @prim

    #+begin_src python
    def prim(name):
        def decorator(fun):
            prim_dict[name] = fun
            return fun
        return decorator
    #+end_src

*** stack operation

    #+begin_src python
    @prim('drop')
    def drop(a):
        return ()

    @prim('dup')
    def dup(a):
        return (a, a)

    @prim('over')
    def over(a, b):
        return (a, b, a)

    @prim('tuck')
    def tuck(a, b):
        return (b, a, b)

    @prim('swap')
    def swap(a, b):
        return (b, a)
    #+end_src

*** number

    #+begin_src python
    @prim('add')
    def add(a, b):
        return a + b

    @prim('sub')
    def sub(a, b):
        return a - b

    @prim('mul')
    def mul(a, b):
        return a * b
    #+end_src

*** bool

    #+begin_src python
    @prim('true')
    def true():
        return True

    @prim('false')
    def false():
        return False
    #+end_src

*** equivalence

    #+begin_src python
    @prim('equal?')
    def equal_p(a, b):
        return a == b

    @prim('eq?')
    def eq_p(a, b):
        return a is b
    #+end_src

*** list

    #+begin_src python
    prim('null')(null)
    prim('null?')(null_p)

    prim('cons')(cons)
    prim('cons?')(cons_p)

    prim('list?')(list_p)

    prim('car')(car)
    prim('cdr')(cdr)

    prim('sexp-write')(write_sexp)
    prim('sexp-list-write')(write_sexp_cons)

    prim('list-length')(list_length)
    prim('list-ref')(list_ref)
    prim('list-append')(list_append)
    prim('tail-cons')(tail_cons)
    #+end_src

*** >< dict

    #+begin_src python

    #+end_src

* top_level_keyword_dict

*** [note]

    - top_level_keyword : (-> module, body -- [effect module])

*** top_level_keyword_dict

    #+begin_src python
    top_level_keyword_dict = {}
    #+end_src

*** @top_level_keyword

    #+begin_src python
    def top_level_keyword(name):
        def decorator(fun):
            top_level_keyword_dict[name] = fun
            return fun
        return decorator
    #+end_src

*** (import)

    #+begin_src python
    @top_level_keyword("import")
    def k_import(module, body):
        module_name = car(body)
        imported_module = importlib.import_module(module_name)
        imported_module_dict = getattr(module, 'imported_module_dict')
        imported_module_dict[module_name] = imported_module
    #+end_src

*** (+jojo)

    #+begin_src python
    @top_level_keyword("+jojo")
    def plus_jojo(module, body):
        jojo_name = car(body)
        setattr(module, jojo_name, JOJO(sexp_vect_emit(module, cdr(body))))
    #+end_src

*** (+macro)

    #+begin_src python
    @top_level_keyword("+macro")
    def plus_macro(module, body):
        jojo_name = car(body)
        setattr(module, jojo_name, MACRO(sexp_vect_emit(module, cdr(body))))
    #+end_src

*** (note)

    #+begin_src python
    @top_level_keyword("note")
    def top_level_note(module, body):
        pass
    #+end_src

* keyword_dict

*** [note]

    - keyword : (-> module, body -- jo vect)

*** keyword_dict

    #+begin_src python
    keyword_dict = {}
    #+end_src

*** @keyword

    #+begin_src python
    def keyword(name):
        def decorator(fun):
            keyword_dict[name] = fun
            return fun
        return decorator
    #+end_src

*** (begin)

    #+begin_src python
    @keyword('begin')
    def k_begin(module, body):
        return sexp_vect_emit(module, body)
    #+end_src

*** (clo)

    #+begin_src python
    @keyword('clo')
    def k_clo(module, body):
        return [CLO(sexp_vect_emit(module, body))]
    #+end_src

*** (if)

    #+begin_src python
    @keyword('if')
    def k_if(module, body):
        jo_vect = sexp_vect_emit(module, body)
        jo_vect.append(IFTE)
        return jo_vect
    #+end_src

*** (quote)

    #+begin_src python
    @keyword('quote')
    def k_quote(module, body):
        jo_vect = list_to_vect(body)
        return jo_vect
    #+end_src

*** >< (partquote)

*** >< (@)

* macro_dict

*** [note]

    - macro : (-> body -- sexp)

*** macro_dict

    #+begin_src python
    macro_dict = {}
    #+end_src

*** @macro

    #+begin_src python
    def macro(name):
        def decorator(fun):
            macro_dict[name] = fun
            return fun
        return decorator
    #+end_src

*** (cond)

    #+begin_src python
    @macro('cond')
    def k_cond(body):
        def recur(rest):
            if list_length(rest) == 2:
                q = list_ref(rest, 0)
                a = list_ref(rest, 1)
                if q == 'else':
                    return a
                else:
                    return vect_to_sexp(
                        ['begin',
                         q, ['clo', a],
                         ['clo',
                          ['quote', body],
                          'report-cond-mismatch'],
                         'ifte'])
            else:
                q = list_ref(rest, 0)
                a = list_ref(rest, 1)
                return vect_to_sexp(
                    ['begin',
                     q, ['clo', a],
                     ['clo', recur(cdr(cdr(rest)))],
                     'ifte'])
        return recur(body)

    @prim('report-cond-mismatch')
    def report_cond_mismatch(body):
        print ("- cond mismatch")
        write ("  body : ")
        write_sexp(body)
        print ("")
        raise JOJO_ERROR()
    #+end_src

* create_module

  #+begin_src python
  def create_module(name, path):
      path = os.path.abspath(path)

      if not os.path.exists(path):
          print ("- create_module fail")
          print ("  path does not exist")
          print ("  path : {}".format(path))
          raise JOJO_ERROR()

      if not os.path.isfile(path):
          print ("- create_module fail")
          print ("  path is not file")
          print ("  path : {}".format(path))
          raise JOJO_ERROR()

      with open(path, "r") as f:
          code = f.read()
          sexp_vect = parse_sexp_vect(scan_string_vect(code))
          module = compile_module(name, sexp_vect)

      module.__file__ = path

      return module
  #+end_src
